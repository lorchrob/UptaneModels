theory ExampleProtocol
begin

  builtins: symmetric-encryption, asymmetric-encryption, revealing-signing

  rule key_gen:
  [ Fr(~secret_key) ]
  -->
  [ !Pk($ID, pk(~secret_key)), !Ltk($ID, ~secret_key) ]

  rule first_message:
  [ !Pk('A', public_key_a) ]
  -->
  [ Out(<'B', public_key_a>) ]

  rule second_message:
  [ In(<'B', public_key_a>), !Ltk('B', secret_key_b), Fr(~session_key) ]
  --[ SendKey(~session_key) ]->
  [ Out(<'A', aenc(revealSign(~session_key, secret_key_b), public_key_a)>) ]

  rule third_message:
  let sig = adec(signed_encrypted_key, secret_key_a)
      session_key = getMessage(sig)
  in
  [ In(<'A', signed_encrypted_key>), 
    Fr(~secret), !Ltk('A', secret_key_a), !Pk('B', public_key_b) ]
  --[ Eq(revealVerify(sig, session_key, public_key_b), true), ReceiveKey(session_key), Secret(~secret) ]->
  [ Out(<'B', senc(~secret, session_key)>) ]

  restriction Equality:
    "All x y #i. Eq(x, y) @#i ==> x = y"

  lemma secrecy:
    "All s #i. Secret(s) @#i ==> not (Ex #j. K(s) @#j)"

  lemma authentication:
    "All k #i. ReceiveKey(k) @#i ==> (Ex #j. SendKey(k) @#j & #j < #i)"
end