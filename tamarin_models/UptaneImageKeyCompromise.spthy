theory UptaneImage
begin

//heuristic: o "oracle"

builtins: hashing, asymmetric-encryption, signing

  //////////////////////////
  ///////// RULES //////////
  //////////////////////////

  // Key compromise rule allowing the adversary to update
  // the primary's targets metadata
  rule primary_update_metadata:
  [
    PriLatestTargetsDir(image_hashes, sigs),
    In( <new_image_hashes, new_sigs> )
  ]
  -->
  [
    PriLatestTargetsDir(new_image_hashes, new_sigs)
  ]

  /* ---------- Everything else equivalent to UptaneImage.spthy ---------- */

  /// KEY GENERATION ///
  // Generate public key
  rule generate_key_pair:
  [ Fr(~secret_key) ]
  --[ GenKeyPair(~secret_key), Unique($ID) ]->
  [ !Ltk($ID, ~secret_key), !Pk($ID, pk(~secret_key)) ]

  // Get public key
  rule get_public_key:
  [ !Pk($ID, public_key) ]
  --[ GetPubKey(public_key) ]->
  [ Out(public_key) ]

  /// INITIALIZATION ///
  rule initialize:
  [ 
    Fr(~root_seckey1), Fr(~root_seckey2), Fr(~timestamp_seckey1), 
    Fr(~timestamp_seckey2), Fr(~snapshot_seckey1), Fr(~snapshot_seckey2), 
    Fr(~targets_seckey1), Fr(~targets_seckey2), Fr(~snapshot), 

    Fr(~root_seckey3), Fr(~root_seckey4), Fr(~timestamp_seckey3), 
    Fr(~timestamp_seckey4), Fr(~snapshot_seckey3), Fr(~snapshot_seckey4), 
    Fr(~targets_seckey3), Fr(~targets_seckey4), Fr(~snapshot2), 

    Fr(~primary_image), Fr(~secondary_image)
  ]
  --[ Unique('initialize') ]->
  [ 
    //// Primary metadata from director ////
    PriMetaDir(
      // Root metadata
      <
        pk(~root_seckey1), pk(~root_seckey2),
        pk(~timestamp_seckey1), pk(~timestamp_seckey2), 
        pk(~snapshot_seckey1), pk(~snapshot_seckey2), 
        pk(~targets_seckey1), pk(~targets_seckey2)
      >,
      // Timestamp metadata
      h(~snapshot), 
      // Snapshot metadata
      ~snapshot, 
      // Targets metadata
      < h(~primary_image), h(~secondary_image) >,
      // Targets signatures
      <
        sign(< h(~primary_image), h(~secondary_image) >, ~targets_seckey1), 
        sign(< h(~primary_image), h(~secondary_image) >, ~targets_seckey2)
      >,
      // State
      'Not_verifying'
    ),

    PriLatestTargetsDir(< h(~primary_image), h(~secondary_image) >, 
      <
        sign(< h(~primary_image), h(~secondary_image) >, ~targets_seckey1), 
        sign(< h(~primary_image), h(~secondary_image) >, ~targets_seckey2)
      >
    ),

    //// Primary metadata from image repo ////
    PriMetaImg(
      // Root metadata
      <
        pk(~root_seckey3), pk(~root_seckey4),
        pk(~timestamp_seckey3), pk(~timestamp_seckey4), 
        pk(~snapshot_seckey3), pk(~snapshot_seckey4), 
        pk(~targets_seckey3), pk(~targets_seckey4)
      >,
      // Timestamp metadata
      h(~snapshot2), 
      // Snapshot metadata
      ~snapshot2, 
      // Targets metadata
      <h(~primary_image), h(~secondary_image)>,
      // Targets signatures
      <
        sign(< h(~primary_image), h(~secondary_image) >, ~targets_seckey3), 
        sign(< h(~primary_image), h(~secondary_image) >, ~targets_seckey4)
      >,
      // State
      'Initialized'
    ),
    PriVerifyLimit('0'),

    !DirectorState(
      <
        // Root metadata
        < pk(~root_seckey1), pk(~root_seckey2), 
        pk(~timestamp_seckey1), pk(~timestamp_seckey2),
        pk(~snapshot_seckey1), pk(~snapshot_seckey2),
        pk(~targets_seckey1), pk(~targets_seckey2) >,
        // Timestamp metadata
        h(~snapshot), 
        // Snapshot metadata
        ~snapshot, 
        // Targets metadata
        < h(~primary_image), h(~secondary_image) >
      >,

      //// Director keys ////
      // Keys
      <
        ~root_seckey1, ~root_seckey2, 
        ~timestamp_seckey1, ~timestamp_seckey2, 
        ~snapshot_seckey1, ~snapshot_seckey2, 
        ~targets_seckey1, ~targets_seckey2
      >,

      // Old keys
      < ~root_seckey1, ~root_seckey2 >,

      // Version
      '0'
    ),

    !ImageState(
      // Metadata
      <
        // Root metadata
        < pk(~root_seckey3), pk(~root_seckey4), pk(~timestamp_seckey3), 
          pk(~timestamp_seckey4), pk(~snapshot_seckey3), pk(~snapshot_seckey4), 
          pk(~targets_seckey3), pk(~targets_seckey4) >,
        // Timestamp metadata
        h(~snapshot2), 
        // Snapshot metadata
        ~snapshot2, 
        // Targets metadata
        < h(~primary_image), h(~secondary_image) >
      >,
      // Keys
      <
        ~root_seckey3, ~root_seckey4, ~timestamp_seckey3, ~timestamp_seckey4, 
        ~snapshot_seckey3, ~snapshot_seckey4, ~targets_seckey3, ~targets_seckey4 
      >,
      // Old keys
      <
        ~root_seckey3, ~root_seckey4
      >,
      // Images
      <
        ~primary_image, ~secondary_image
      >,
      // Version
      '0'
    ),

    SecMetaDir(
      < 
        //pk(~root_seckey1), pk(~root_seckey2),
        pk(~targets_seckey1), pk(~targets_seckey2)
      >,
      < h(~primary_image), h(~secondary_image) >
    ),

    SecMetaImg(
      < 
        pk(~root_seckey3), pk(~root_seckey4),
        pk(~targets_seckey3), pk(~targets_seckey4)
      >,
      < h(~primary_image), h(~secondary_image) >
    )
  ]

  //// IMAGE REPO ////
  rule image_gen_nonroot_metadata:
  [
    !ImageState(
      <
        // Root metadata
        < pk(~root_seckey1), pk(~root_seckey2), pk(~timestamp_seckey1), 
          pk(~timestamp_seckey2), pk(~snapshot_seckey1), pk(~snapshot_seckey2), 
          pk(~targets_seckey1), pk(~targets_seckey2) >,
        // Timestamp metadata
        h(snapshot), 
        // Snapshot metadata
        snapshot, 
        // Targets metadata
        < primary_image_hash, secondary_image_hash >
      >,
      keys, old_keys,
      <
        primary_image, secondary_image
      >,
      '0'
    ),
    Fr(~new_snapshot), 
    Fr(~new_primary_image), Fr(~new_secondary_image)
  ]
  --[ Unique('image_gen_nonroot_metadata') ]->
  [
    !ImageState(
      <
        // Root metadata
        < pk(~root_seckey1), pk(~root_seckey2), pk(~timestamp_seckey1), 
          pk(~timestamp_seckey2), pk(~snapshot_seckey1), pk(~snapshot_seckey2), 
          pk(~targets_seckey1), pk(~targets_seckey2) >,
        // Timestamp metadata
        h(~new_snapshot), 
        // Snapshot metadata
        ~new_snapshot, 
        // Targets metadata
        < h(~new_primary_image),h(~new_secondary_image) >
      >,
      keys, old_keys,
      <
        ~new_primary_image, ~new_secondary_image
      >,
      '1'
    )
  ]
 
  // Image repo sends images to primary
  rule image_send_primary_images:
  [ 
    !Pk('ECU', ecu_encryption_key), 
    !ImageState(metadata, keys, old_keys, <~primary_image, ~secondary_image>, version)
  ]
  --[ ImgSendImages(aenc(~primary_image, ecu_encryption_key), aenc(~secondary_image, ecu_encryption_key)), 
      Unique('image_send_primary_images') ]->
  [ 
    Out(<'Image', 'Send_Image', aenc(~primary_image, ecu_encryption_key), 
         aenc(~secondary_image, ecu_encryption_key)>)
  ]

  // Primary verifies images for itself and secondary
  rule primary_verify_images:
  [ 
    !Ltk('ECU', ~ecu_decryption_key), 
    In(< encrypted_image_primary, encrypted_image_secondary >),
    PriLatestTargetsDir(<image_hash_primary, image_hash_secondary>, sigs)
  ]
  --[ Eq(h(adec(encrypted_image_primary, ~ecu_decryption_key)), image_hash_primary),
      Eq(h(adec(encrypted_image_secondary, ~ecu_decryption_key)), image_hash_secondary),
      VerifyImages(encrypted_image_primary, encrypted_image_secondary),
      Twice('primary_verify_images')
    ]->
  [ 
    PriLatestTargetsDir(< image_hash_primary, image_hash_secondary >, sigs),
    SecImageVerified(encrypted_image_secondary)
  ]

  // Primary sends image to secondary
  rule primary_send_image:
  [ 
    SecImageVerified(encrypted_image)
  ]
  --[ PriSendIm(encrypted_image), Unique('primary_send_image') ]->
  [ Out(< encrypted_image >) ]

  // Secondary verifies image from primary
  rule secondary_verify_image:
  [ 
    !Ltk('ECU', ecu_decryption_key), 
    In(< encrypted_image >),
    SecMetaDir(root, <image_hash_primary, image_hash_secondary>) 
  ]
  --[ 
      Eq(h(adec(encrypted_image, ecu_decryption_key)), image_hash_secondary),
      VerifyImageSec(encrypted_image),
      Twice('secondary_verify_image')
    ]->
  [ SecMetaDir(root, <image_hash_primary, image_hash_secondary>) ]

  //////////////////////////
  ////// RESTRICTIONS //////
  //////////////////////////

  restriction Equality:
    "All x y #i. Eq(x, y) @#i ==> x = y"

  restriction Unique:
    "All x #i #j. Unique(x) @#i & Unique(x) @#j ==> #i = #j"
  
  restriction Twice:
    "All x #i #j #k. Twice(x) @#i & Twice(x) @#j & Twice(x) @#k ==> #i = #j | #i = #k | #j = #k"

  //////////////////////////
  ///////// LEMMAS /////////
  //////////////////////////  
  
  //// Sanity-check lemmas
  lemma sanity_check1:
    exists-trace 
      "Ex img1 img2 #i. VerifyImages(img1, img2) @#i"

  lemma sanity_check2:
    exists-trace 
      "Ex img #i. VerifyImageSec(img) @#i"

  
  //// Weak authentication lemmas
  lemma image_weak_auth1: 
    "All img1 img2 #i. (VerifyImages(img1, img2) @#i ==> 
      (Ex #j. ImgSendImages(img1, img2) @#j & #j<#i))"

  // This weak authentication lemma fails. But, on inspection
  // of the counterexample, the adversary still cannot
  // perform __arbitrary__ message injections.
  // In the counterexample, the adversary injects an image to the secondary 
  // that was sent from the image repo to the primary. But, no other
  // injections are possible, as proven by the next lemma "image_authentication_sec2".
  // So a *standard attacker* in the CRV model is not
  // applicable here.
  lemma image_weak_auth_sec1: 
    "All img #i. (VerifyImageSec(img) @#i ==> 
      (Ex #j. PriSendIm(img) @#j & #j<#i))"
  
  lemma image_weak_auth_sec2: 
    "All img #i. (VerifyImageSec(img) @#i ==> 
      (Ex img2 #j. ImgSendImages(img2, img) @#j & #j<#i))"

  //// Strong authentication lemmas
  lemma image_strong_auth_sec1:
  "All m #i. VerifyImageSec(m) @#i ==> 
    (Ex m2 #j. ImgSendImages(m2, m) @#j
      & #j < #i
      & not (Ex #i2. VerifyImageSec(m) @#i2
                            & not (#i2 = #i)))"

  lemma image_strong_auth_sec2:
  "All m1 m2 #i. VerifyImages(m1, m2) @#i ==> 
    (Ex #j. ImgSendImages(m1, m2) @#j
      & #j < #i
      & not (Ex #i2. VerifyImages(m1, m2) @#i2
                            & not (#i2 = #i)))"
 end