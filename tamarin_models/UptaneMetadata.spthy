theory UptaneMetadata
begin

heuristic: o "oracle"

builtins: hashing, asymmetric-encryption, signing

  //////////////////////////
  ///////// RULES //////////
  //////////////////////////

  /// KEY GENERATION ///
  // Generate public key
  rule generate_key_pair:
  [ Fr(~secret_key) ]
  --[ GenKeyPair(~secret_key), Unique($ID) ]->
  [ !Ltk($ID, ~secret_key), !Pk($ID, pk(~secret_key)) ]

  // Get public key
  rule get_public_key:
  [ !Pk($ID, public_key) ]
  --[ GetPubKey(public_key) ]->
  [ Out(public_key) ]

  /// INITIALIZATION ///
  rule initialize:
  [ 
    Fr(~root_seckey1), Fr(~root_seckey2), Fr(~timestamp_seckey1), 
    Fr(~timestamp_seckey2), Fr(~snapshot_seckey1), Fr(~snapshot_seckey2), 
    Fr(~targets_seckey1), Fr(~targets_seckey2), Fr(~snapshot), 

    Fr(~root_seckey3), Fr(~root_seckey4), Fr(~timestamp_seckey3), 
    Fr(~timestamp_seckey4), Fr(~snapshot_seckey3), Fr(~snapshot_seckey4), 
    Fr(~targets_seckey3), Fr(~targets_seckey4), Fr(~snapshot2), 

    Fr(~primary_image), Fr(~secondary_image)
  ]
  --[ Unique('initialize') ]->
  [ 
    //// Primary metadata ////
    PriMeta(
      // Root metadata
      <
        pk(~root_seckey1), pk(~root_seckey2),
        pk(~timestamp_seckey1), pk(~timestamp_seckey2), 
        pk(~snapshot_seckey1), pk(~snapshot_seckey2), 
        pk(~targets_seckey1), pk(~targets_seckey2)
      >,
      // Timestamp metadata
      h(~snapshot), 
      // Snapshot metadata
      ~snapshot, 
      // Targets metadata
      < h(~primary_image), h(~secondary_image) >,
      // Targets signatures
      <
        sign(< h(~primary_image), h(~secondary_image) >, ~targets_seckey1), 
        sign(< h(~primary_image), h(~secondary_image) >, ~targets_seckey2)
      >,
      // State
      'Not_verifying'
    ),

    PriLatestTargets(< h(~primary_image), h(~secondary_image) >, 
      <
        sign(< h(~primary_image), h(~secondary_image) >, ~targets_seckey1), 
        sign(< h(~primary_image), h(~secondary_image) >, ~targets_seckey2)
      >
    ),

    PriVerifyLimit('0'),

    !RepoState(
      <
        // Root metadata
        < pk(~root_seckey1), pk(~root_seckey2), 
        pk(~timestamp_seckey1), pk(~timestamp_seckey2),
        pk(~snapshot_seckey1), pk(~snapshot_seckey2),
        pk(~targets_seckey1), pk(~targets_seckey2) >,
        // Timestamp metadata
        h(~snapshot), 
        // Snapshot metadata
        ~snapshot, 
        // Targets metadata
        < h(~primary_image), h(~secondary_image) >
      >,

      //// Director keys ////
      // Keys
      <
        ~root_seckey1, ~root_seckey2, 
        ~timestamp_seckey1, ~timestamp_seckey2, 
        ~snapshot_seckey1, ~snapshot_seckey2, 
        ~targets_seckey1, ~targets_seckey2
      >,

      // Old keys
      < ~root_seckey1, ~root_seckey2 >,

      // Version
      '0'
    ),

    !ImageState(
      // Images
      <
        ~primary_image, ~secondary_image
      >,
      // Version
      '0'
    ),

    SecMeta(
      < 
        //pk(~root_seckey1), pk(~root_seckey2),
        pk(~targets_seckey1), pk(~targets_seckey2)
      >,
      < h(~primary_image), h(~secondary_image) >
    )
  ]

  
  //// REPOSITORY ////
  rule gen_nonroot_metadata:
  [
    !ImageState(<~primary_image, ~secondary_image>, version),
    !RepoState(
      <
        // Root metadata
        < pk(~root_seckey1), pk(~root_seckey2), pk(~timestamp_seckey1), 
          pk(~timestamp_seckey2), pk(~snapshot_seckey1), pk(~snapshot_seckey2), 
          pk(~targets_seckey1), pk(~targets_seckey2) >,
        // Timestamp metadata
        h(snapshot), 
        // Snapshot metadata
        snapshot, 
        // Targets metadata
        < primary_image_hash, secondary_image_hash >
      >,
      keys, old_keys, '0'
    ),
    Fr(~new_snapshot)
  ]
  --[Unique('gen_nonroot_metadata')]->
  [
    !RepoState(
      <
        // Root metadata
        < pk(~root_seckey1), pk(~root_seckey2), pk(~timestamp_seckey1), 
          pk(~timestamp_seckey2), pk(~snapshot_seckey1), pk(~snapshot_seckey2), 
          pk(~targets_seckey1), pk(~targets_seckey2) >,
        // Timestamp metadata
        h(~new_snapshot), 
        // Snapshot metadata
        ~new_snapshot, 
        // Targets metadata
        < h(~primary_image), h(~secondary_image) >
        >,
      keys, old_keys, '1'
    )
  ]

  rule gen_root_metadata:
  [
    !RepoState(
      // Metadata
      <
        // Root metadata
        < pk(root_seckey1), pk(root_seckey2), pk(timestamp_seckey1), 
          pk(timestamp_seckey2), pk(snapshot_seckey1), pk(snapshot_seckey2), 
          pk(targets_seckey1), pk(targets_seckey2) >,
        // Timestamp metadata
        h(snapshot), 
        // Snapshot metadata
        snapshot, 
        // Targets metadata
        < primary_image_hash, secondary_image_hash >
      >,
      // Keys
      <
        root_seckey1, root_seckey2, timestamp_seckey1, timestamp_seckey2, 
        snapshot_seckey1, snapshot_seckey2, targets_seckey1, targets_seckey2
      >,
      // Old keys
      <
        a, b
      >,
      // Version
      '1'
    ),

    Fr(~new_root_seckey1), Fr(~new_root_seckey2), Fr(~new_timestamp_seckey1), 
    Fr(~new_timestamp_seckey2), Fr(~new_snapshot_seckey1), Fr(~new_snapshot_seckey2), 
    Fr(~new_targets_seckey1), Fr(~new_targets_seckey2)
  ]
  --[Unique('gen_root_metadata')]->
  [
    !RepoState(
      // Metadata
      <
        // Root metadata
        < pk(~new_root_seckey1), pk(~new_root_seckey2), pk(~new_timestamp_seckey1), 
          pk(~new_timestamp_seckey2), pk(~new_snapshot_seckey1), pk(~new_snapshot_seckey2), 
          pk(~new_targets_seckey1), pk(~new_targets_seckey2) >,
        // Timestamp metadata
        h(snapshot), 
        // Snapshot metadata
        snapshot, 
        // Targets metadata
        < primary_image_hash, secondary_image_hash >
      >,
      // Keys
      <
        ~new_root_seckey1, ~new_root_seckey2, ~new_timestamp_seckey1, 
        ~new_timestamp_seckey2, ~new_snapshot_seckey1, ~new_snapshot_seckey2, 
        ~new_targets_seckey1, ~new_targets_seckey2
      >,
      // Old keys
      <
        root_seckey1, root_seckey2
      >,
      // Version
      '2'
    )
  ]

  rule send_root_metadata:
  let root = <pk(~root_seckey1), pk(~root_seckey2), 
              pk(~ts1), pk(~ts2), pk(~ss1), pk(~ss2), 
              pk(~tr1), pk(~tr2)> in
  [ 
    !RepoState(< root, timestamp, ~snapshot, targets >, 
      < ~root_seckey1, ~root_seckey2, c, d, e, f, g, i >,
      < ~old_root_seckey1, ~old_root_seckey2 >, version)
  ]
  --[
      LatestDirector(version),
      Neq(~root_seckey1, ~root_seckey2),
      SendRootMetadataDir(root),
      Unique('send_root_metadata')
    ]->
  [  
    Out(root),
    Out( <
      sign(root, ~root_seckey1), 
      sign(root, ~root_seckey2),
      sign(root, ~old_root_seckey1), 
      sign(root, ~old_root_seckey2) >)
  ]

  
  rule send_timestamp_metadata:
  let timestamp = h(~snapshot) in
  [ 
    !RepoState(< root, timestamp, ~snapshot, targets >,
      < a, b, ~timestamp_seckey1, ~timestamp_seckey2, c, d, e, f >,
      old_keys, version)
  ]
  --[
      LatestDirector(version),
      Neq(~timestamp_seckey1, ~timestamp_seckey2),
      SendTimestampMetadataDir(timestamp),
      Unique('send_timestamp_metadata')
    ]->
  [  
    Out(timestamp), 
    Out( <
          sign(timestamp, ~timestamp_seckey1), 
          sign(timestamp, ~timestamp_seckey2) >)
  ]
  
  
  rule send_snapshot_metadata:
  [ 
    !RepoState(< root, timestamp, ~snapshot, targets >,
      < a, b, c, d, ~snapshot_seckey1, ~snapshot_seckey2, e, f >,
      old_keys, version)
  ]
  --[
      LatestDirector(version),
      Neq(~snapshot_seckey1, ~snapshot_seckey2),
      SendSnapshotMetadataDir(~snapshot),
      Unique('send_snapshot_metadata')
    ]->
  [  
    Out(~snapshot),
    Out(  <
          sign(~snapshot, ~snapshot_seckey1), 
          sign(~snapshot, ~snapshot_seckey2) >)
  ]

  rule send_targets_metadata:
  let targets = < h(~primary_image), h(~secondary_image) > in
  [ 
    !RepoState(< root, timestamp, snapshot, targets >,
      < a, b, c, d, e, f, ~targets_seckey1, ~targets_seckey2 >,
      old_keys, version) 
  ]
  --[
      LatestDirector(version),
      Neq(~targets_seckey1, ~targets_seckey2),
      SendTargetsMetadataDir(targets),
      SendTargetsCombined(targets),
      Unique('send_targets_metadata')
    ]->
  [  
    Out(targets),
    Out( <
          sign(targets, ~targets_seckey1), 
          sign(targets, ~targets_seckey2) >)
  ]

  // Primary verify director metadata
  rule primary_verify_meta_dir_root:
  let root =    <  pk(~root_seckey1), pk(~root_seckey2), 
                   pk(~timestamp_seckey1), pk(~timestamp_seckey2),
                   pk(~snapshot_seckey1), pk(~snapshot_seckey2),
                   pk(~targets_seckey1), pk(~targets_seckey2) > 
      new_root = < new_root_pubkey1, new_root_pubkey2, 
                   a, b, c, d, e, f > 
  in
  [ 
    In(new_root), 
    In(< sig1, sig2, sig3, sig4 >),
    PriMeta(root, timestamp, snapshot, targets, sigs, any_state)
  ]
  --[ 
    
      Eq(verify(sig1, new_root, pk(~root_seckey1)), true),
      Eq(verify(sig2, new_root, pk(~root_seckey2)), true),
      Eq(verify(sig3, new_root, new_root_pubkey1), true),
      Eq(verify(sig4, new_root, new_root_pubkey2), true),
      PriVerifyMetaDirRoot(new_root),

      Unique('primary_verify_meta_dir_root')
    ]->
  [ 
    PriMeta(new_root, timestamp, snapshot, targets, sigs, 'Verified_meta_dir_root')
  ]
  
  // Primary verify director metadata
  rule primary_verify_meta_dir_timestamp:
  let root = < pk(~root_seckey1), pk(~root_seckey2), 
                   pk(~timestamp_seckey1), pk(~timestamp_seckey2),
                   pk(~snapshot_seckey1), pk(~snapshot_seckey2),
                   pk(~targets_seckey1), pk(~targets_seckey2) >
  in
  [ 
    In(new_timestamp),
    In( < sig5, sig6 >),
    PriMeta(root, timestamp, snapshot, targets, sigs, 'Verified_meta_dir_root')
  ]
  --[ 
      Eq(verify(sig5, new_timestamp, pk(~timestamp_seckey1)), true),
      Eq(verify(sig6, new_timestamp, pk(~timestamp_seckey2)), true),

      PriVerifyMetaDirTimestamp(new_timestamp),

      Unique('primary_verify_meta_dir_timestamp')
    ]->
  [ 
    PriMeta(root, new_timestamp, snapshot, targets, sigs, 'Verified_meta_dir_timestamp')
  ]

  // Primary verify director metadata
  rule primary_verify_meta_dir_snapshot:
  let root = < pk(~root_seckey1), pk(~root_seckey2), 
                   pk(~timestamp_seckey1), pk(~timestamp_seckey2),
                   pk(~snapshot_seckey1), pk(~snapshot_seckey2),
                   pk(~targets_seckey1), pk(~targets_seckey2) > 
  in
  [ 
    In(new_snapshot),
    In(< sig7, sig8 > ),
    PriMeta(root, timestamp, snapshot, targets, sigs, 'Verified_meta_dir_timestamp')
  ]
  --[ 
      Eq(verify(sig7, new_snapshot, pk(~snapshot_seckey1)), true),
      Eq(verify(sig8, new_snapshot, pk(~snapshot_seckey2)), true),

      Eq(h(new_snapshot), timestamp),

      PriVerifyMetaDirSnapshot(new_snapshot),

      Unique('primary_verify_meta_dir_snapshot')
    ]->
  [ 
    PriMeta(root, timestamp, new_snapshot, targets, sigs, 'Verified_meta_dir_snapshot')
  ]

  // Primary verify director metadata
  rule primary_verify_meta_dir_targets:
  let root = < pk(~root_seckey1), pk(~root_seckey2), 
                   pk(~timestamp_seckey1), pk(~timestamp_seckey2),
                   pk(~snapshot_seckey1), pk(~snapshot_seckey2),
                   pk(~targets_seckey1), pk(~targets_seckey2) > 
  in
  [ 
    In(new_targets),
    In(< sig9, sig10 >),
    PriMeta(root, timestamp, snapshot, targets, sigs, 'Verified_meta_dir_snapshot'),
    //PriMeta(root, timestamp, snapshot, targets, sigs, any_state),
    PriLatestTargets(targets, < sig1, sig2> )
  ]
  --[ 
      Eq(verify(sig9, new_targets, pk(~targets_seckey1)), true),
      Eq(verify(sig10, new_targets, pk(~targets_seckey2)), true),

      PriVerifyMetaDirTargets(new_targets),

      Unique('primary_verify_meta_dir_targets')
      //Twice('primary_verify_meta_dir_targets')
    ]->
  [ 
    PriMeta(root, timestamp, snapshot, new_targets, < sig9, sig10 >, 'Verified_meta_dir_targets'),
    PriLatestTargets(new_targets, < sig9, sig10 >)
  ]
  
  // Primary sends metadata to secondary
  rule primary_send_metadata:
  let targets = < h(~primary_image), h(~secondary_image) >
      sig1 = sign(< h(~primary_image), h(~secondary_image) >, ~targets_seckey1)
      sig2 = sign(< h(~primary_image), h(~secondary_image) >, ~targets_seckey2) in
    [ 
      //PriMeta(root, timestamp, snapshot, targets, < sig1, sig2 >, 'Not_verifying')
      PriLatestTargets(targets, < sig1, sig2> )
    ]
    --[PriSendMeta(targets), 
       SendTargetsCombined(targets),
       Unique('primary_send_metadata')]->
    [ 
      Out(< targets, sig1, sig2 >),
      //PriMeta(root, timestamp, snapshot, targets, < sig1, sig2 >, 'Not_verifying')
      PriLatestTargets(targets, < sig1, sig2> )
    ]
    
  // Secondary verifies director metadata from primary
  rule secondary_verify_metadata:
  [  
    In(< new_targets, sig1, sig2 >),
    SecMeta(< targets_pubkey1, targets_pubkey2 >, targets)
  ]
  --[ 
      Neq(targets_pubkey1, targets_pubkey2),
      Eq(verify(sig1, new_targets, targets_pubkey1), true),
      Eq(verify(sig2, new_targets, targets_pubkey2), true),
      SecVerifyTargetsMetadataDir(new_targets),

      Unique('secondary_verify_metadata')
    ]->
  [     
    SecMeta(< targets_pubkey1, targets_pubkey2 >, new_targets)
  ]

  //////////////////////////
  ////// RESTRICTIONS //////
  //////////////////////////

  restriction Equality:
    "All x y #i. Eq(x, y) @#i ==> x = y"

  restriction LatestDirector:
    "(All x #i #j. LatestDirector('0') @#i & LatestDirector(x) @#j ==>
        x = '0' | #i < #j) &
     (All x #i #j. LatestDirector('1') @#i & LatestDirector(x) @#j ==>
        x = '1' | x = '0' | #i < #j) & 
     (All x #i #j. LatestDirector('2') @#i & LatestDirector(x) @#j ==>
        x = '2' | x = '1' | x = '0' | #i < #j)"

  restriction Unique:
    "All x #i #j. Unique(x) @#i & Unique(x) @#j ==> #i = #j"

  restriction Twice:
    "All x #i #j #k. Twice(x) @#i & Twice(x) @#j & Twice(x) @#k ==> #i = #j | #i = #k | #j = #k"

  //////////////////////////
  ///////// LEMMAS /////////
  //////////////////////////  

  // Sanity checks
  lemma sanity_check1:
    exists-trace 
      "Ex meta #i. PriVerifyMetaDirRoot(meta) @#i"

  lemma sanity_check2:
    exists-trace 
      "Ex meta #i. PriVerifyMetaDirTimestamp(meta) @#i"

  lemma sanity_check3:
    exists-trace 
      "Ex meta #i. PriVerifyMetaDirSnapshot(meta) @#i"

  lemma sanity_check4:
    exists-trace 
      "Ex meta #i. PriVerifyMetaDirTargets(meta) @#i"

  lemma sanity_check5:
    exists-trace 
      "Ex meta #i. SecVerifyTargetsMetadataDir(meta) @#i"
    
  // Weak and strong authentication
  lemma root_dir_meta_weak_auth: 
    "All root #i. (PriVerifyMetaDirRoot(root) @#i ==> 
      (Ex #j. SendRootMetadataDir(root) @#j & #j<#i))"

  
  // For _all_ strong auth lemmas, to be meaningful,
  // we need to update the restriction in the corresponding
  // verification rule  from "Unique(...)" to "Twice(...)". This is because for the lemma to fail,
  // the verification rule must fire twice. For faster termination,
  // also leave the prior verification state to be unrestricted
  // (e.g., change the state of 'Verified_meta_dir_snapshot' to
  //  any_state, without quotes).
  // This allows the verification rule to fire twice in a row,
  // which is functionally equivalent to all prior verification stages
  // being replayed (which we know is feasible from prior strong auth lemmas failing).
  lemma root_dir_meta_strong_auth:
    "All m #i. PriVerifyMetaDirRoot(m) @#i ==> 
      (Ex #j. SendRootMetadataDir(m) @#j
        & #j < #i
        & not (Ex #i2. PriVerifyMetaDirRoot(m) @#i2
                             & not (#i2 = #i)))"

  lemma timestamp_dir_meta_weak_auth: 
    "All ts #i. (PriVerifyMetaDirTimestamp(ts) @#i ==> 
      (Ex #j. SendTimestampMetadataDir(ts) @#j & #j<#i))"

  lemma timestamp_dir_meta_strong_auth:
    "All m #i. PriVerifyMetaDirTimestamp(m) @#i ==> 
      (Ex #j. SendTimestampMetadataDir(m) @#j
        & #j < #i
        & not (Ex #i2. PriVerifyMetaDirTimestamp(m) @#i2
                              & not (#i2 = #i)))"

  lemma snapshot_dir_meta_weak_auth: 
    "All ss #i. (PriVerifyMetaDirSnapshot(ss) @#i ==> 
      (Ex #j. SendSnapshotMetadataDir(ss) @#j & #j<#i))"

  lemma snapshot_dir_meta_strong_auth:
    "All m #i. PriVerifyMetaDirSnapshot(m) @#i ==> 
      (Ex #j. SendSnapshotMetadataDir(m) @#j
        & #j < #i
        & not (Ex #i2. PriVerifyMetaDirSnapshot(m) @#i2
                              & not (#i2 = #i)))"

  // This weak authentication lemma fails. But, on inspection
  // of the counterexample, the adversary still cannot
  // perform __arbitrary__ message injections.
  // In the counterexample, the adversary injects metadata to the primary 
  // that was previously sent from the to the primary. But, no other
  // injections are possible, as proven by the next lemma "targets_dir_meta_weak_auth2".
  // So a *standard attacker* in the CRV model is not
  // applicable here.
  lemma targets_dir_meta_weak_auth1: 
    "All targets #i. (PriVerifyMetaDirTargets(targets) @#i ==> 
      (Ex #j. SendTargetsMetadataDir(targets) @#j & #j<#i))"

  lemma targets_dir_meta_weak_auth2: 
    "All targets #i. (PriVerifyMetaDirTargets(targets) @#i ==> 
      ((Ex #j. SendTargetsMetadataDir(targets) @#j & #j<#i) |
       (Ex #j. PriSendMeta(targets) @#j & #j<#i)))"

  // SendTargetsCombined is the combination of SendTargetsMetadataDir and PriSendMeta.
  lemma targets_dir_meta_strong_auth:
    "All m #i. PriVerifyMetaDirTargets(m) @#i ==> 
      (Ex #j. SendTargetsCombined(m) @#j
        & #j < #i
        & not (Ex #i2. PriVerifyMetaDirTargets(m) @#i2
                              & not (#i2 = #i)))"

  // This weak authentication lemma fails. But, on inspection
  // of the counterexample, the adversary still cannot
  // perform __arbitrary__ message injections.
  // In the counterexample, the adversary injects metadata to the secondary 
  // that was sent from the repo to the primary. But, no other
  // injections are possible, as proven by the next lemma "meta_weak_auth_sec2".
  // So a *standard attacker* in the CRV model is not
  // applicable here.
  lemma meta_weak_auth_sec1: 
    "All targets #i. (SecVerifyTargetsMetadataDir(targets) @#i ==> 
      (Ex #j. PriSendMeta(targets) @#j & #j<#i))"

  lemma meta_weak_auth_sec2: 
    "All targets #i. (SecVerifyTargetsMetadataDir(targets) @#i ==> 
      (Ex #j. SendTargetsMetadataDir(targets) @#j & #j<#i) |
      (Ex #j. PriSendMeta(targets) @#j & #j<#i))"

  lemma meta_strong_auth_sec:
    "All m #i. SecVerifyTargetsMetadataDir(m) @#i ==> 
      (Ex #j. SendTargetsMetadataDir(m) @#j
        & #j < #i
        & not (Ex #i2. SecVerifyTargetsMetadataDir(m) @#i2
                              & not (#i2 = #i))) |
      (Ex #j. PriSendMeta(m) @#j
        & #j < #i
        & not (Ex #i2. SecVerifyTargetsMetadataDir(m) @#i2
                              & not (#i2 = #i)))"

  lemma meta_strong_auth_sec2:
    "All m #i #j. SecVerifyTargetsMetadataDir(m) @#i & PriSendMeta(m) @#j & #j < #i  ==> 
      (not (Ex #i2. SecVerifyTargetsMetadataDir(m) @#i2 & not (#i2 = #i)))"

  lemma meta_strong_auth_sec3:
    "All m #i. SecVerifyTargetsMetadataDir(m) @#i ==> 
      (Ex #j. PriSendMeta(m) @#j
        & #j < #i
        & not (Ex #i2. SecVerifyTargetsMetadataDir(m) @#i2
                              & not (#i2 = #i)))"
 end