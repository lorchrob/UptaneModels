package Agree_Nodes
public
	with Data_Types;
	
	annex agree {**
			
		-- HasHappened(X) is true iff X has been true at least once so far
		node HasHappened(X : bool) returns (Y : bool);
		let
  			Y = X or (false -> pre (Y)) ;
		tel;

		-- Initially(X) is true iff X was true at the initial step
		node InitiallyX(X: bool) returns (Y: bool);
		let
  			Y = X -> true;
		tel;
		
		node Duration(p: bool) returns (r: int) ;
		let   
			r = (if p then 1 else 0) -> (if p then pre(r) + 1 else 0) ;
		tel;
		
		node Sofar(X : bool ) returns ( Y : bool );
		let
 			Y = X -> (X and (pre(Y)));
		tel;
		
		node Since(X: bool, Y : bool ) returns (Z : bool);
		let
  			Z =  X or (Y and (false -> pre(Z)));
		tel;
		
		node ToInt(b: bool) returns (i: int);
		let
			i = if b then 1 else 0;
		tel;
		
		-- Bogus/abstract predicates
		node Match(X: int, Z: int) returns (B: bool);
		let
			B = Z - 5 <= X and X <= Z + 5;
		tel;

		node Compatible(X: int, Y: int) returns (Z: bool);
		let
			Z = Y - 5 <= X and X <= Y + 5;
		tel;

		node Compatible3(X: int, Y: int, Z: int) returns (o: bool);
		let
			o = (0 <= X + Y + Z) and (X + Y + Z < 10);
		tel;

		node AuthoredByOem(X: Data_Types::Image.impl) returns (Z: bool);
		let
			Z = (X.filename >= 0);
		tel;

		-- We model a hash as the identity function because we're assuming a perfectly secure
		-- hash function, and the identity is an easy 1-to-1 function (no collisions)
		node HashImg(X: Data_Types::Image.impl) returns (Y: Data_Types::Image.impl);
		let
			Y = X;
		tel;

		node HashMan(X: Data_Types::VehicleVersionManifest.impl) returns (Y: Data_Types::VehicleVersionManifest.impl);
		let
			Y = X;
		tel;

		node HashVRep(X: Data_Types::EcuVersionReport.impl) returns (Y: Data_Types::EcuVersionReport.impl);
		let
			Y = X;
		tel;

		node HashRoot(X: Data_Types::RootMetadata.impl) returns (Y: Data_Types::RootMetadata.impl);
		let
			Y = X;
		tel;

		node HashTimestamp(X: Data_Types::TimestampMetadata.impl) returns (Y: Data_Types::TimestampMetadata.impl);
		let
			Y = X;
		tel;

		node HashSnapshot(X: Data_Types::SnapshotMetadata.impl) returns (Y: Data_Types::SnapshotMetadata.impl);
		let
			Y = X;
		tel;

		node HashTargets(X: Data_Types::TargetsMetadata.impl) returns (Y: Data_Types::TargetsMetadata.impl);
		let
			Y = X;
		tel;
	**};
end Agree_Nodes;