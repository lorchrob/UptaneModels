-- TODO
--	 1. Fill out guarantees (see comments at the end of individual components)
--   2. Trim down model
--   3. Look into "SHOULD" parts of the protocol 

package Uptane

public
	with Data_Types;
	with Base_Types;
	with Agree_Nodes;
	with Agree_Constants;
	with CASE_Consolidated_Properties;

	-----------------------------------------
	--------- DIRECTOR REPOSITORY -----------
	-----------------------------------------
	system DirectorRepo
		-- The Director Repository exposes a public interface for the download of metadata. This metadata
		-- is generated/updated on-demand by the Director upon receiving a valid vehicle version manifest.

		features
			-- Inputs
			initialization: in data port Data_Types::InitializationBus.impl;
			in_primary: in data port Data_Types::PrimaryToDirector.impl;
			
			-- Outputs
			out_primary: out data port Data_Types::DirectorToPrimary.impl;

			-- Model outputs
			latest_targets: out data port Data_Types::TargetsMetadata.impl;
			
			-- Assumes and Guarantees
			annex agree {**
				-- Director known information about ECUs-- ECU IDs and keys
				eq primary_ecu_id: int = (initialization.ecu_id_one -> pre (primary_ecu_id));
				eq secondary_ecu_id: int = (initialization.ecu_id_two -> pre (secondary_ecu_id));
				eq secondary_ecu_id2: int = (initialization.ecu_id_three -> pre (secondary_ecu_id2));
				eq primary_ecu_key: int = (initialization.ecu_key_one -> pre (primary_ecu_key));
				eq secondary_ecu_key: int = (initialization.ecu_key_two -> pre (secondary_ecu_key));
				eq secondary_ecu_key2: int = (initialization.ecu_key_three -> pre (secondary_ecu_key2));
				eq hardware_id_one: int = initialization.hardware_id_one -> pre (hardware_id_one);
				eq hardware_id_two: int = initialization.hardware_id_two -> pre (hardware_id_two);
				eq hardware_id_three: int = initialization.hardware_id_three -> pre (hardware_id_three);

				eq valid_manifest: bool = false -> (initialization.optional_features_flag => (
				  -- Fresh nonces
					-- SHOULD
					(
						(pre (in_primary.manifest.report_one.nonce)) > pre (current_manifest.report_one.nonce)
						and
						(pre (in_primary.manifest.report_two.nonce)) > pre (current_manifest.report_two.nonce)
						and
						(pre (in_primary.manifest.report_three.nonce)) > pre (current_manifest.report_three.nonce)
					) and
					-- Matching ecu ids
					-- SHOULD
					(
						(pre (in_primary.manifest.report_one.ecu_id)) = primary_ecu_id 
						and
						(pre (in_primary.manifest.report_two.ecu_id)) = secondary_ecu_id
						and
						(pre (in_primary.manifest.report_three.ecu_id)) = secondary_ecu_id2
					) and
					-- Valid signatures
					-- SHOULD
					(					
						Agree_Nodes::Match(pre (in_primary.manifest.signature), pre (in_primary.manifest.hash), primary_ecu_key) and
						Agree_Nodes::Match(pre (in_primary.manifest.report_one.signature), pre (in_primary.manifest.report_one.hash), primary_ecu_key) and
						Agree_Nodes::Match(pre (in_primary.manifest.report_two.signature), pre (in_primary.manifest.report_two.hash), secondary_ecu_key) and
						Agree_Nodes::Match(pre (in_primary.manifest.report_three.signature), pre (in_primary.manifest.report_three.hash), secondary_ecu_key2)
					)
				));

				eq current_manifest: Data_Types::VehicleVersionManifest.impl = initialization.manifest -> (if valid_manifest then pre (in_primary.manifest) else pre (current_manifest));

				guarantee "Test guarantee to make partial bundle pass in benign case":
					true -> (out_primary.metadata.root_metadata.targets_public_keys = pre (out_primary.metadata.root_metadata.targets_public_keys)) and
					true -> (out_primary.metadata.root_metadata.targets_threshold_signatures = pre (out_primary.metadata.root_metadata.targets_threshold_signatures));


				-- MODEL
				guarantee "The Director repo sends metadata if and only if there is a request from the Primary":
					(out_primary.metadata_response.root_metadata = (false -> pre (in_primary.metadata_request.root_metadata))) and
					(out_primary.metadata_response.targets_metadata = (false  -> pre (in_primary.metadata_request.targets_metadata))) and
					(out_primary.metadata_response.snapshot_metadata = (false -> pre (in_primary.metadata_request.snapshot_metadata))) and
					(out_primary.metadata_response.timestamp_metadata = (false -> pre (in_primary.metadata_request.timestamp_metadata)));

				-- SHALL
				guarantee "The Director repo only generates new metadata upon receiving a vehicle version manifest":
					true -> 
					((not pre (in_primary.manifest_present)) => (out_primary.metadata = pre (out_primary.metadata)))

				-- SHALL
				guarantee "The Director determines the suitable set of images by managing dependencies and conflicts":
					Agree_Nodes::Compatible3(out_primary.metadata.targets_metadata.image_filenames.filename_one, 
																	 out_primary.metadata.targets_metadata.image_filenames.filename_two,
																	 out_primary.metadata.targets_metadata.image_filenames.filename_three);
					
				-- SHOULD
				guarantee "The Director makes sure that each image is compatible with its corresponding ECU": 
					initialization.optional_features_flag => (
						Agree_Nodes::Compatible(out_primary.metadata.targets_metadata.image_filenames.filename_one, hardware_id_one) and
						Agree_Nodes::Compatible(out_primary.metadata.targets_metadata.image_filenames.filename_two, hardware_id_two)
					);

				-- IMPLICIT ASSUMPTION
				guarantee "Well-formedness guarantees":
					out_primary.metadata.targets_metadata.hardware_ids.hardware_id_one = hardware_id_one and
					out_primary.metadata.targets_metadata.hardware_ids.hardware_id_two = hardware_id_two and
					(true -> (out_primary.metadata.targets_metadata.release_counters.release_counter_one >= pre(out_primary.metadata.targets_metadata.release_counters.release_counter_one))) and
					(true -> (out_primary.metadata.targets_metadata.release_counters.release_counter_two >= pre(out_primary.metadata.targets_metadata.release_counters.release_counter_two))) and
					(true -> (out_primary.metadata.targets_metadata.release_counters.release_counter_three >= pre(out_primary.metadata.targets_metadata.release_counters.release_counter_three)));

				-- SHOULD
				guarantee "The Director repo checks the vehicle version manifest for validity before generating new metadata":
					initialization.optional_features_flag => (
						true ->
						((not valid_manifest) => (out_primary.metadata = pre (out_primary.metadata)))
					);

				-- SHOULD
				guarantee "Metadata file version numbers are incremented when the file is updated":
					initialization.optional_features_flag => (
						true -> (
							((out_primary.metadata.root_metadata <> pre (out_primary.metadata.root_metadata)) =>
								(out_primary.metadata.root_metadata.common_payload.version = (pre (out_primary.metadata.root_metadata.common_payload.version) + 1))) and
							((out_primary.metadata.timestamp_metadata <> pre (out_primary.metadata.timestamp_metadata)) =>
								(out_primary.metadata.timestamp_metadata.common_payload.version = (pre (out_primary.metadata.timestamp_metadata.common_payload.version) + 1))) and
							((out_primary.metadata.targets_metadata <> pre (out_primary.metadata.targets_metadata)) =>
								(out_primary.metadata.targets_metadata.common_payload.version = (pre (out_primary.metadata.targets_metadata.common_payload.version) + 1))) and
							((out_primary.metadata.snapshot_metadata <> pre (out_primary.metadata.snapshot_metadata)) =>
								(out_primary.metadata.snapshot_metadata.common_payload.version = (pre (out_primary.metadata.snapshot_metadata.common_payload.version) + 1)))
						)
					);

				-- MODEL
				guarantee "Set initial metadata":
					(out_primary.metadata = initialization.metadata_d) -> true;

				-- MODEL
				guarantee "Director only tells ECUs to download images authored by OEMs":
					Agree_Nodes::AuthoredByOem(out_primary.metadata.targets_metadata.image_hashes.hash_one) and
					Agree_Nodes::AuthoredByOem(out_primary.metadata.targets_metadata.image_hashes.hash_two) and
					Agree_Nodes::AuthoredByOem(out_primary.metadata.targets_metadata.image_hashes.hash_three);

				-- MODEL
				guarantee "Set the probe":
					latest_targets = 
					(initialization.metadata_d.targets_metadata ->
						(if out_primary.metadata_response.targets_metadata then out_primary.metadata.targets_metadata else pre latest_targets));
				-- Might want new images/metadata to be dependent on information from the manifest.
				-- But, this is not actually part of the standard.
			**};
	end DirectorRepo;

	-----------------------------------------
	--------- Image REPOSITORY --------------
	-----------------------------------------
	system ImageRepo
	-- The Image Repository exposes a public interface for the download of software images and metadata.

		features
			-- Inputs
			initialization: in data port Data_Types::InitializationBus.impl;
			in_primary: in data port Data_Types::PrimaryToImage.impl;
			--in_images: in data port Data_Types::ImageSet.impl;
			
			-- Outputs
			out_primary: out data port Data_Types::ImageToPrimary.impl;

			-- Assumes and Guarantees
			annex agree {**
				--eq image_set: Data_Types::ImageSet.impl = in_images -> pre (image_set);
				eq hardware_id_one: int = initialization.hardware_id_one -> pre (hardware_id_one);
				eq hardware_id_two: int = initialization.hardware_id_two -> pre (hardware_id_two);
				eq hardware_id_three: int = initialization.hardware_id_three -> pre (hardware_id_three);

				guarantee "Test guarantee to make partial bundle pass in benign case":
					true -> (out_primary.metadata.root_metadata.targets_public_keys = pre (out_primary.metadata.root_metadata.targets_public_keys));

				-- INITIALIZATION (MODEL)
				guarantee "Initialize the Image repo":
					(
						(out_primary.metadata = initialization.metadata_i) and
						(out_primary.image = initialization.primary_image) and
						(out_primary.image_secondary = initialization.secondary_image) and
						(out_primary.image_secondary2 = initialization.secondary_image2)
					) -> true;

				-- SHALL
				guarantee "The Image Repo sends metadata and images if and only if there is a request from the Primary, ie,
				          	the Image Repo provides an interface for the download of metadata and images":
					(out_primary.metadata_response.root_metadata = (false -> pre (in_primary.metadata_request.root_metadata))) and
					(out_primary.metadata_response.targets_metadata = (false -> pre (in_primary.metadata_request.targets_metadata))) and
					(out_primary.metadata_response.snapshot_metadata = (false -> pre (in_primary.metadata_request.snapshot_metadata))) and
					(out_primary.metadata_response.timestamp_metadata = (false -> pre (in_primary.metadata_request.timestamp_metadata))) and
					(out_primary.image_response = (false -> pre (in_primary.image_request)));

				-- SHALL
				guarantee "The Image Repo sends the correct images based on the Primary's request":
				true -> (
					(out_primary.image.filename = (pre (in_primary.image_filename))) and
					(out_primary.image.hash = (pre (in_primary.image_hash))) and
					(out_primary.image_secondary.filename = pre (in_primary.image_filename_secondary)) and
					(out_primary.image_secondary.hash = pre (in_primary.image_hash_secondary)) and
					(out_primary.image_secondary2.filename = pre (in_primary.image_filename_secondary2)) and
					(out_primary.image_secondary2.hash = pre (in_primary.image_hash_secondary2))
				);

				-- IMPLICIT ASSUMPTION
				guarantee "The Image Repository correctly generates Targets metadata, that is, the targets metadata generated
				           by the repository matches the images available.":
					out_primary.image.version = out_primary.metadata.targets_metadata.release_counters.release_counter_one and
					out_primary.image_secondary.version = out_primary.metadata.targets_metadata.release_counters.release_counter_two and
					out_primary.image_secondary2.version = out_primary.metadata.targets_metadata.release_counters.release_counter_three and
					out_primary.image.filename = out_primary.metadata.targets_metadata.image_filenames.filename_one and
					out_primary.image_secondary.filename = out_primary.metadata.targets_metadata.image_filenames.filename_two and
					out_primary.image_secondary2.filename = out_primary.metadata.targets_metadata.image_filenames.filename_three and
					out_primary.image.hash = out_primary.metadata.targets_metadata.image_hashes.hash_one and
					out_primary.image_secondary.hash = out_primary.metadata.targets_metadata.image_hashes.hash_two and
					out_primary.image_secondary2.hash = out_primary.metadata.targets_metadata.image_hashes.hash_three and
					out_primary.metadata.targets_metadata.hardware_ids.hardware_id_one = hardware_id_one and
					out_primary.metadata.targets_metadata.hardware_ids.hardware_id_two = hardware_id_two and
					out_primary.metadata.targets_metadata.hardware_ids.hardware_id_three = hardware_id_three;

				-- IMPLICIT ASSUMPTION
				-- Otherwise, (eg) images can fail verification without attack, causing mixed bundle/incompatibility
				-- issues even in the benign case. For example, one ECU might successfully update while the other
				-- fails verification, leaving ECUs with incompatible images.
				guarantee "All images are authored by a legitimate OEM":
					Agree_Nodes::AuthoredByOem(out_primary.image.hash) and
					Agree_Nodes::AuthoredByOem(out_primary.image_secondary.hash) and
					Agree_Nodes::AuthoredByOem(out_primary.image_secondary2.hash) and
					Agree_Nodes::AuthoredByOem(out_primary.metadata.targets_metadata.image_hashes.hash_one) and
					Agree_Nodes::AuthoredByOem(out_primary.metadata.targets_metadata.image_hashes.hash_two) and
					Agree_Nodes::AuthoredByOem(out_primary.metadata.targets_metadata.image_hashes.hash_three);

				-- SHALL
				guarantee "The image hash uniquely identifies the image":
					true -> (
						out_primary.image.hash >= pre (out_primary.image.hash) and
						out_primary.image_secondary.hash >= pre (out_primary.image_secondary.hash) and
						out_primary.image_secondary2.hash >= pre (out_primary.image_secondary2.hash) and
						((out_primary.image.hash = pre (out_primary.image.hash)) => out_primary.image = pre (out_primary.image)) and
						((out_primary.image_secondary.hash = pre (out_primary.image_secondary.hash)) => out_primary.image_secondary = pre (out_primary.image_secondary)) and
						((out_primary.image_secondary2.hash = pre (out_primary.image_secondary2.hash)) => out_primary.image_secondary2 = pre (out_primary.image_secondary2))
					);

				-- SHOULD
				guarantee "Metadata file version numbers are incremented when the file is updated":
					initialization.optional_features_flag => (
						true -> (
							((out_primary.metadata.root_metadata <> pre (out_primary.metadata.root_metadata)) =>
								(out_primary.metadata.root_metadata.common_payload.version = (pre (out_primary.metadata.root_metadata.common_payload.version) + 1))) and
							((out_primary.metadata.timestamp_metadata <> pre (out_primary.metadata.timestamp_metadata)) =>
								(out_primary.metadata.timestamp_metadata.common_payload.version = (pre (out_primary.metadata.timestamp_metadata.common_payload.version) + 1))) and
							((out_primary.metadata.targets_metadata <> pre (out_primary.metadata.targets_metadata)) =>
								(out_primary.metadata.targets_metadata.common_payload.version = (pre (out_primary.metadata.targets_metadata.common_payload.version) + 1))) and
							((out_primary.metadata.snapshot_metadata <> pre (out_primary.metadata.snapshot_metadata)) =>
								(out_primary.metadata.snapshot_metadata.common_payload.version = (pre (out_primary.metadata.snapshot_metadata.common_payload.version) + 1)))
						)
					);

				-- May need to include additional guarantees on the metadata or images
			**};
	end ImageRepo;


	-----------------------------------------
	--------- PRIMARY ECU -------------------
	-----------------------------------------
	system PrimaryEcu
	-- The Primary ECU performs communication with the repositories, downloads metadata
	-- and images, and distributes the metadata and images to the secondary ECUs (after
	-- performing full verification).

		features
			-- Inputs
			initialization: in data port Data_Types::InitializationBus.impl;
			in_director: in data port Data_Types::DirectorToPrimary.impl;
			in_image: in data port Data_Types::ImageToPrimary.impl;
			in_secondary: in data port Data_Types::SecondaryToPrimary.impl;
			in_secondary2: in data port Data_Types::SecondaryToPrimary.impl;
			in_time_server: in data port Data_Types::TimeServerToPrimary.impl;
			
			-- Outputs
			out_director: out data port Data_Types::PrimaryToDirector.impl;
			out_image: out data port Data_Types::PrimaryToImage.impl;
			out_secondary: out data port Data_Types::PrimaryToSecondary.impl;
			out_secondary2: out data port Data_Types::PrimaryToSecondary.impl;

			-- Model outputs
			installed_image_primary: out data port Data_Types::Image.impl
			{CASE_Consolidated_Properties::probe => true; };
			verification_stage_primary: out data port Data_Types::VerificationStage
			{CASE_Consolidated_Properties::probe => true; };
			verified_metadata_primary_d: out data port Data_Types::Metadata.impl
			{CASE_Consolidated_Properties::probe => true; };
			verified_metadata_primary_i: out data port Data_Types::Metadata.impl
			{CASE_Consolidated_Properties::probe => true; };
			latest_targets_director: out data port Data_Types::TargetsMetadata.impl
			{CASE_Consolidated_Properties::probe => true; };
			ecu_software_version_primary: out data port Base_Types::Integer
			{CASE_Consolidated_Properties::probe => true; };
			
			-- Assumes and Guarantees
			annex agree {**
				-- Guard optional guarantees
				eq optional_flag: bool = true;

				eq ecu_id: int = initialization.ecu_id_one -> pre (ecu_id);	
				eq ecu_key: int = initialization.ecu_key_one -> pre (ecu_key);
				eq hardware_id: int = initialization.hardware_id_one -> pre (hardware_id);
				eq hardware_id_secondary: int = initialization.hardware_id_two -> pre (hardware_id_secondary);
				eq hardware_id_secondary2: int = initialization.hardware_id_three -> pre (hardware_id_secondary2);
				eq initial_image: Data_Types::Image.impl = initialization.primary_image -> pre (initial_image);
				eq current_time: int = in_time_server.current_time;
				eq most_recent_secondary_report: Data_Types::EcuVersionReport.impl = initialization.report_two -> (if pre (in_secondary.report_present) then pre (in_secondary.ecu_version_report) else pre (most_recent_secondary_report));
				eq most_recent_secondary_report2: Data_Types::EcuVersionReport.impl = initialization.report_three -> (if pre (in_secondary2.report_present) then pre (in_secondary2.ecu_version_report) else pre (most_recent_secondary_report2));
				-- Currently punting on attack detection
				eq attack_detected: bool = false; 
				eq previous_nonce: int = 0 -> if pre (out_director.manifest_present) 
																			then pre (out_director.manifest.report_one.nonce) 
																			else pre (previous_nonce);

				eq current_targets_director: Data_Types::TargetsMetadata.impl = verified_metadata_primary_d.targets_metadata;										
				eq previous_targets: Data_Types::TargetsMetadata.impl = initialization.metadata_d.targets_metadata -> if targets_director_verified then pre (verified_metadata_primary_d.targets_metadata)
				                																																		                else pre (previous_targets);	

				eq new_image_verified: bool = 
					-- We are not in the middle of verifying metadata
					(verification_stage_primary = Agree_Constants::VERIFY_SUCCESS) and
				  -- There is an incoming image
					(false -> pre (in_image.image_response)) and
					-- The image's hardware ID matches this ECU's hardware ID (based on targets metadata)
				  current_targets_director.hardware_ids.hardware_id_one = hardware_id and
					-- The image's release counter is greater than or equal to the previous image's release counter
					-- (based on targets metadata)
					-- SHOULD
					(initialization.optional_features_flag => 
					(true -> (current_targets_director.release_counters.release_counter_one >= previous_targets.release_counters.release_counter_one))) and
					-- The image's hash matches the hash listed in the metadata
					(false -> (current_targets_director.image_hashes.hash_one	= pre (in_image.image.hash))); 

				eq new_image_verified_secondary: bool = 
					-- We are not in the middle of verifying metadata
					(verification_stage_primary = Agree_Constants::VERIFY_SUCCESS) and
				  -- There is an incoming image
					(false -> pre (in_image.image_response)) and
					-- The image's hardware ID matches this ECU's hardware ID (based on targets metadata)
				  current_targets_director.hardware_ids.hardware_id_two = hardware_id_secondary and
					-- The image's release counter is greater than or equal to the previous image's release counter
					-- (based on targets metadata)
					-- SHOULD
					(initialization.optional_features_flag => 
					(true -> (current_targets_director.release_counters.release_counter_two >= previous_targets.release_counters.release_counter_two))) and
					-- The image's hash matches the hash listed in the metadata
					(false -> (current_targets_director.image_hashes.hash_two	= pre (in_image.image_secondary.hash))); 

				eq new_image_verified_secondary2: bool = 
					-- We are not in the middle of verifying metadata
					(verification_stage_primary = Agree_Constants::VERIFY_SUCCESS) and
				  -- There is an incoming image
					(false -> pre (in_image.image_response)) and
					-- The image's hardware ID matches this ECU's hardware ID (based on targets metadata)
				  current_targets_director.hardware_ids.hardware_id_three = hardware_id_secondary2 and
					-- The image's release counter is greater than or equal to the previous image's release counter
					-- (based on targets metadata)
					-- SHOULD
					(initialization.optional_features_flag => 
					(true -> (current_targets_director.release_counters.release_counter_three >= previous_targets.release_counters.release_counter_three))) and
					-- The image's hash matches the hash listed in the metadata
					(false -> (current_targets_director.image_hashes.hash_three	= pre (in_image.image_secondary2.hash))); 

				eq root_director_verified: bool = false -> (
					-- We have incoming root metadata from the director
					(in_director.metadata_response.root_metadata) and 
					-- We are in the correct step of verification
					(pre (verification_stage_primary) = Agree_Constants::VERIFY_SUCCESS) and
					-- The payload is properly signed
					(verified_metadata_primary_d.root_metadata.root_threshold_signatures <= 2) and
					(Agree_Nodes::Match(in_director.metadata.root_metadata.common_payload.signatures.signature_one, 
					                   in_director.metadata.root_metadata.common_payload.hash,
														 verified_metadata_primary_d.root_metadata.root_public_keys.key_one)) and
				  (Agree_Nodes::Match(in_director.metadata.root_metadata.common_payload.signatures.signature_two, 
					                   in_director.metadata.root_metadata.common_payload.hash,
														 verified_metadata_primary_d.root_metadata.root_public_keys.key_two)) and
					-- The version number is non-decreasing
					(in_director.metadata.root_metadata.common_payload.version >= pre (verified_metadata_primary_d.root_metadata.common_payload.version)) and
					-- The metadata is not expired
					(in_director.metadata.root_metadata.common_payload.expiration > current_time) and
					-- The new Root metadata is signed by keys specified in the new root metadata
					(Agree_Nodes::Match(in_director.metadata.root_metadata.common_payload.signatures.signature_one, 
					                   in_director.metadata.root_metadata.common_payload.hash,
														 in_director.metadata.root_metadata.root_public_keys.key_one)) and
					(Agree_Nodes::Match(in_director.metadata.root_metadata.common_payload.signatures.signature_two, 
					                   in_director.metadata.root_metadata.common_payload.hash,
														 in_director.metadata.root_metadata.root_public_keys.key_two))
				);

				eq timestamp_director_verified: bool = false -> (
					-- We have incoming timestamp metadata
					(in_director.metadata_response.timestamp_metadata) and 
					-- We are in the correct verification stage
					((pre (verification_stage_primary) = Agree_Constants::ROOT_D)) and
					-- We have the correct number of valid signatures
					(verified_metadata_primary_d.root_metadata.timestamp_threshold_signatures <= 2) and
					(Agree_Nodes::Match(in_director.metadata.timestamp_metadata.common_payload.signatures.signature_one, 
					                   in_director.metadata.timestamp_metadata.common_payload.hash,
														 verified_metadata_primary_d.root_metadata.timestamp_public_keys.key_one)) and
					(Agree_Nodes::Match(in_director.metadata.timestamp_metadata.common_payload.signatures.signature_two, 
					                   in_director.metadata.timestamp_metadata.common_payload.hash,
														 verified_metadata_primary_d.root_metadata.timestamp_public_keys.key_two)) and
					-- The version number is non-decreasing
					(in_director.metadata.timestamp_metadata.common_payload.version >= pre (verified_metadata_primary_d.timestamp_metadata.common_payload.version)) and
					-- The metadata is not expired
					(in_director.metadata.timestamp_metadata.common_payload.expiration > current_time)
				);

				eq snapshot_director_verified: bool = false -> (
					-- We have incoming snapshot metadata
				  in_director.metadata_response.snapshot_metadata and
					-- We are in the correct verification stage
					(pre (verification_stage_primary) = Agree_Constants::TIMESTAMP_D) and
					-- We have the correct number of valid signatures
					verified_metadata_primary_d.root_metadata.snapshot_threshold_signatures <= 2 and
					Agree_Nodes::Match(in_director.metadata.snapshot_metadata.common_payload.signatures.signature_one, 
					                   in_director.metadata.snapshot_metadata.common_payload.hash,
														 verified_metadata_primary_d.root_metadata.snapshot_public_keys.key_one) and
					Agree_Nodes::Match(in_director.metadata.snapshot_metadata.common_payload.signatures.signature_two, 
					                   in_director.metadata.snapshot_metadata.common_payload.hash,
														 verified_metadata_primary_d.root_metadata.snapshot_public_keys.key_two) and
					-- The version number is non-decreasing
					(in_director.metadata.snapshot_metadata.common_payload.version >= pre (verified_metadata_primary_d.snapshot_metadata.common_payload.version)) and
					-- The metadata is not expired
					in_director.metadata.snapshot_metadata.common_payload.expiration > current_time and 
				  -- The new Snapshot metadata hashes and version number match those in Timestamp metadata
					in_director.metadata.snapshot_metadata.hashes = verified_metadata_primary_d.timestamp_metadata.latest_snapshot_hashes and
					in_director.metadata.snapshot_metadata.common_payload.version = verified_metadata_primary_d.timestamp_metadata.latest_snapshot_version and
				  -- The new Snapshot metadata lists a newer (or identical) version number for each Targets metadata file
					(in_director.metadata.snapshot_metadata.targets_version_numbers.version_number_one >= pre (verified_metadata_primary_d.snapshot_metadata.targets_version_numbers.version_number_one)) and
					(in_director.metadata.snapshot_metadata.targets_version_numbers.version_number_two >= pre (verified_metadata_primary_d.snapshot_metadata.targets_version_numbers.version_number_two)) and
					(in_director.metadata.snapshot_metadata.targets_version_numbers.version_number_three >= pre (verified_metadata_primary_d.snapshot_metadata.targets_version_numbers.version_number_three)) and
			  	-- The new Snapshot metadata contains info for all the Targets metadata files listed in the previous Snapshot metadata
					(in_director.metadata.snapshot_metadata.targets_filenames.filename_one = pre (verified_metadata_primary_d.snapshot_metadata.targets_filenames.filename_one)) and
					(in_director.metadata.snapshot_metadata.targets_filenames.filename_two = pre (verified_metadata_primary_d.snapshot_metadata.targets_filenames.filename_two)) and
					(in_director.metadata.snapshot_metadata.targets_filenames.filename_three = pre (verified_metadata_primary_d.snapshot_metadata.targets_filenames.filename_three))
				);

				eq targets_director_verified: bool = false -> (
					-- We have incoming targets metadata
					in_director.metadata_response.targets_metadata and 
					-- We are in the correct verification stage
					((pre (verification_stage_primary) = Agree_Constants::SNAPSHOT_D)) and
					-- We have the correct number of valid signatures
					verified_metadata_primary_d.root_metadata.targets_threshold_signatures <= 2 and
          Agree_Nodes::Match(in_director.metadata.targets_metadata.common_payload.signatures.signature_one, 
					                   in_director.metadata.targets_metadata.common_payload.hash,
														 verified_metadata_primary_d.root_metadata.targets_public_keys.key_one) and
					Agree_Nodes::Match(in_director.metadata.targets_metadata.common_payload.signatures.signature_two, 
					                   in_director.metadata.targets_metadata.common_payload.hash,
														 verified_metadata_primary_d.root_metadata.targets_public_keys.key_two) and
					-- The version number is non-decreasing
					(in_director.metadata.targets_metadata.common_payload.version >= pre (verified_metadata_primary_d.targets_metadata.common_payload.version)) and
					-- The metadata is not expired
					in_director.metadata.targets_metadata.common_payload.expiration > current_time and
				  -- The new Targets metadata does not list the same ECU ID multiple times
					(
						in_director.metadata.targets_metadata.ecu_ids.ecu_id_one <> in_director.metadata.targets_metadata.ecu_ids.ecu_id_two and
						in_director.metadata.targets_metadata.ecu_ids.ecu_id_one <> in_director.metadata.targets_metadata.ecu_ids.ecu_id_three and
						in_director.metadata.targets_metadata.ecu_ids.ecu_id_two <> in_director.metadata.targets_metadata.ecu_ids.ecu_id_three
					)
				);

				eq root_image_verified: bool = false -> (
					-- We have incoming root metadata
					in_image.metadata_response.root_metadata and 
					-- We are in the correct stage of verification
					((pre (verification_stage_primary) = Agree_Constants::TARGETS_D)) and
					-- We have the correct number of valid signatures
					verified_metadata_primary_i.root_metadata.root_threshold_signatures <= 2 and
					Agree_Nodes::Match(in_image.metadata.root_metadata.common_payload.signatures.signature_one, 
					                   in_image.metadata.root_metadata.common_payload.hash,
														 verified_metadata_primary_i.root_metadata.root_public_keys.key_one) and
					Agree_Nodes::Match(in_image.metadata.root_metadata.common_payload.signatures.signature_two, 
					                   in_image.metadata.root_metadata.common_payload.hash,
														 verified_metadata_primary_i.root_metadata.root_public_keys.key_two) and
					-- The version number is non-decreasing
					(in_image.metadata.root_metadata.common_payload.version >= pre (verified_metadata_primary_i.root_metadata.common_payload.version)) and
					-- The metadata is not expired
					in_image.metadata.root_metadata.common_payload.expiration > current_time and
					-- The new Root metadata is signed by keys specified in the new root metadata
					Agree_Nodes::Match(in_image.metadata.root_metadata.common_payload.signatures.signature_one, 
					                   in_image.metadata.root_metadata.common_payload.hash,
														 in_image.metadata.root_metadata.root_public_keys.key_one) and
					Agree_Nodes::Match(in_image.metadata.root_metadata.common_payload.signatures.signature_two, 
					                   in_image.metadata.root_metadata.common_payload.hash,
														 in_image.metadata.root_metadata.root_public_keys.key_two)
				);
		  	
				eq timestamp_image_verified: bool = false -> (
					-- We have incoming metadata
					in_image.metadata_response.timestamp_metadata and
					-- We are in the correct stage of verification
					((pre (verification_stage_primary) = Agree_Constants::ROOT_I)) and
					-- We have the correct number of valid signatures
					verified_metadata_primary_i.root_metadata.timestamp_threshold_signatures <= 2 and
					Agree_Nodes::Match(in_image.metadata.timestamp_metadata.common_payload.signatures.signature_one, 
					                   in_image.metadata.timestamp_metadata.common_payload.hash,
														 verified_metadata_primary_i.root_metadata.timestamp_public_keys.key_one) and
					Agree_Nodes::Match(in_image.metadata.timestamp_metadata.common_payload.signatures.signature_two, 
					                   in_image.metadata.timestamp_metadata.common_payload.hash,
														 verified_metadata_primary_i.root_metadata.timestamp_public_keys.key_two) and
					-- The version number is non-decreasing
					(in_image.metadata.timestamp_metadata.common_payload.version >= pre (verified_metadata_primary_i.timestamp_metadata.common_payload.version)) and
					-- The metadata is not expired
					in_image.metadata.timestamp_metadata.common_payload.expiration > current_time
				);
				
				eq snapshot_image_verified: bool = false -> (
					-- We have incoming metadata
					in_image.metadata_response.snapshot_metadata and
					-- We are in the correct verification stage
					((pre (verification_stage_primary) = Agree_Constants::TIMESTAMP_I)) and
					-- We have the correct number of valid signatures
					verified_metadata_primary_i.root_metadata.snapshot_threshold_signatures <= 2 and
					Agree_Nodes::Match(in_image.metadata.snapshot_metadata.common_payload.signatures.signature_one, 
					                   in_image.metadata.snapshot_metadata.common_payload.hash,
														 verified_metadata_primary_i.root_metadata.snapshot_public_keys.key_one) and
					Agree_Nodes::Match(in_image.metadata.snapshot_metadata.common_payload.signatures.signature_two, 
					                   in_image.metadata.snapshot_metadata.common_payload.hash,
														 verified_metadata_primary_i.root_metadata.snapshot_public_keys.key_two) and
					-- The version number is non-decreasing
					(in_image.metadata.snapshot_metadata.common_payload.version >= pre (verified_metadata_primary_i.snapshot_metadata.common_payload.version)) and
					-- The metadata is not expired
					in_image.metadata.snapshot_metadata.common_payload.expiration > current_time and 
				  -- The new Snapshot metadata hashes and version number match those in Timestamp metadata
					in_image.metadata.snapshot_metadata.hashes = verified_metadata_primary_i.timestamp_metadata.latest_snapshot_hashes and
					in_image.metadata.snapshot_metadata.common_payload.version = verified_metadata_primary_i.timestamp_metadata.latest_snapshot_version and
				  -- The new Snapshot metadata lists a newer (or identical) version number for each Targets metadata file
					(in_image.metadata.snapshot_metadata.targets_version_numbers.version_number_one >= pre (verified_metadata_primary_i.snapshot_metadata.targets_version_numbers.version_number_one)) and
					(in_image.metadata.snapshot_metadata.targets_version_numbers.version_number_two >= pre (verified_metadata_primary_i.snapshot_metadata.targets_version_numbers.version_number_two)) and
					(in_image.metadata.snapshot_metadata.targets_version_numbers.version_number_three >= pre (verified_metadata_primary_i.snapshot_metadata.targets_version_numbers.version_number_three)) and
			  	-- The new Snapshot metadata contains info for all the Targets metadata files listed in the previous Snapshot metadata
					(in_image.metadata.snapshot_metadata.targets_filenames.filename_one = pre (verified_metadata_primary_i.snapshot_metadata.targets_filenames.filename_one)) and
					(in_image.metadata.snapshot_metadata.targets_filenames.filename_two = pre (verified_metadata_primary_i.snapshot_metadata.targets_filenames.filename_two)) and
					(in_image.metadata.snapshot_metadata.targets_filenames.filename_three = pre (verified_metadata_primary_i.snapshot_metadata.targets_filenames.filename_three))
				);

				eq targets_image_verified: bool = false -> (
					-- We have incoming metadata
				  in_image.metadata_response.targets_metadata and
					-- We are in the correct stage of verification
					((pre (verification_stage_primary) = Agree_Constants::SNAPSHOT_I)) and
					-- We have the correct number of valid signatures
					verified_metadata_primary_i.root_metadata.targets_threshold_signatures <= 2 and
          Agree_Nodes::Match(in_image.metadata.targets_metadata.common_payload.signatures.signature_one, 
					                   in_image.metadata.targets_metadata.common_payload.hash,
														 verified_metadata_primary_i.root_metadata.targets_public_keys.key_one) and
					Agree_Nodes::Match(in_image.metadata.targets_metadata.common_payload.signatures.signature_two, 
					                   in_image.metadata.targets_metadata.common_payload.hash,
														 verified_metadata_primary_i.root_metadata.targets_public_keys.key_two) and
					-- The version number is non-decreasing
					(in_image.metadata.targets_metadata.common_payload.version >= pre (verified_metadata_primary_i.targets_metadata.common_payload.version)) and
					-- EXTRA ASSUMPTION NEEDED: the expiration time must be far enough in the future such that
					-- the secondary can also verify the metadata. If not, we can get partial bundle issues with no attacker. (verify this)
					-- The metadata is not expired
					in_image.metadata.targets_metadata.common_payload.expiration > (current_time + 1) and
				  -- The new Targets metadata does not list the same ECU ID multiple times
					(
						in_image.metadata.targets_metadata.ecu_ids.ecu_id_one <> in_image.metadata.targets_metadata.ecu_ids.ecu_id_two and
						in_image.metadata.targets_metadata.ecu_ids.ecu_id_one <> in_image.metadata.targets_metadata.ecu_ids.ecu_id_three and
						in_image.metadata.targets_metadata.ecu_ids.ecu_id_two <> in_image.metadata.targets_metadata.ecu_ids.ecu_id_three
					)
				);

				eq targets_match_verified: bool = false -> (
					-- We have incoming metadata
					in_image.metadata_response.targets_metadata and
					-- We are in the correct stage of verification
					((pre (verification_stage_primary) = Agree_Constants::TARGETS_I)) and
					-- The targets metadata from the image repo matches the targets metadata from the director
					in_image.metadata.targets_metadata.image_filenames = latest_targets_director.image_filenames and
					in_image.metadata.targets_metadata.image_hashes = latest_targets_director.image_hashes and
					in_image.metadata.targets_metadata.image_file_sizes = latest_targets_director.image_file_sizes and

					-- SHOULD
					(initialization.optional_features_flag => 
					(in_image.metadata.targets_metadata.release_counters = latest_targets_director.release_counters)) and

					in_image.metadata.targets_metadata.ecu_ids = latest_targets_director.ecu_ids and
					in_image.metadata.targets_metadata.hardware_ids = latest_targets_director.hardware_ids and

					-- SHOULD
					-- The release counter is non-decreasing
					(initialization.optional_features_flag => 
					(in_image.metadata.targets_metadata.release_counters.release_counter_one <= previous_targets.release_counters.release_counter_one and
					 in_image.metadata.targets_metadata.release_counters.release_counter_two <= previous_targets.release_counters.release_counter_two and
					 in_image.metadata.targets_metadata.release_counters.release_counter_three <= previous_targets.release_counters.release_counter_three))
				);


				-------------------------------------
				--- COMMUNICATION WITH SECONDARY  ---
				-------------------------------------
				-- SHOULD
				guarantee "The Primary ECU sends the current time to the secondary":
					(initialization.optional_features_flag => 
					(out_secondary.current_time = current_time)) and
					(out_secondary2.current_time = current_time)) and
					((out_secondary.current_time <> pre (out_secondary.current_time)) = (true -> out_secondary.time_present)) and
					((out_secondary2.current_time <> pre (out_secondary2.current_time)) = (true -> out_secondary2.time_present));

				-- SHALL
				guarantee "The primary sends the correct metadata and images to the secondary":
					(out_secondary.metadata = verified_metadata_primary_d) and
					(out_secondary2.metadata = verified_metadata_primary_d);
					-- The image sent to the secondary is set in the "IMAGE VERIFICATION" section

				-- Should maybe be included, but it's not in the standard. It's commented out so that the primary
				-- can always send the correct image to the corresponding secondary
				--guarantee "The primary broadcasts metadata/images to all secondaries":
					--out_secondary = out_secondary2;
					
				--------------------------------------------------------
				--- ECU VERSION REPORTS AND VEHICLE VERSION MANIFEST ---
				--------------------------------------------------------
				-- SHALL
				guarantee "The manifest sends the correct ECU version report for the secondary in the vehicle version manifest":
					out_director.manifest_present => 
					((out_director.manifest.report_two = most_recent_secondary_report) and
					 (out_director.manifest.report_three = most_recent_secondary_report2));

				-- SHALL
				guarantee "The vehicle version manifest signature matches the payload":
					out_director.manifest_present =>
					Agree_Nodes::Match(out_director.manifest.signature,
					                   out_director.manifest.hash,
														 ecu_key);

				-- SHALL
				guarantee "The ECU version report signature matches the payload":
					out_director.manifest_present =>
					Agree_Nodes::Match(out_director.manifest.report_one.signature, 
					                   out_director.manifest.report_one.hash, 
														 ecu_key);

				-- SHALL
				guarantee "The ECU version report's ECU ID matches this ECU's ID":
					out_director.manifest_present => (out_director.manifest.report_one.ecu_id = ecu_id);

				-- SHALL
				guarantee "The ECU's currently installed image metadata matches the version report's information (filename, length, and hashes)":
					out_director.manifest_present => 
					(
						installed_image_primary.filename = out_director.manifest.report_one.image_filename and
					  installed_image_primary.hash = out_director.manifest.report_one.image_hash and
						installed_image_primary.length = out_director.manifest.report_one.image_length
					);

				-- SHALL
				guarantee "The ECU version report lists the current time":
					out_director.manifest.report_one.latest_time = current_time;

				-- SHALL
				guarantee "The ECU version report's nonce changes each update cycle":
					out_director.manifest_present => 
					out_director.manifest.report_one.nonce > previous_nonce;

				-- SHOULD
				--guarantee "The ECU version report notes any detected attacks":
					--(initialization.optional_features_flag => 
					--(out_director.manifest.report_one.attack_detected = attack_detected));

				--------------------------
				--- IMAGE VERIFICATION ---
				--------------------------
				-- SHALL
				guarantee "The ECU downloads the correct images":
					out_image.image_filename = verified_metadata_primary_d.targets_metadata.image_filenames.filename_one and
					out_image.image_hash = verified_metadata_primary_d.targets_metadata.image_hashes.hash_one and
					out_image.image_filename_secondary = verified_metadata_primary_d.targets_metadata.image_filenames.filename_two and
					out_image.image_filename_secondary2 = verified_metadata_primary_d.targets_metadata.image_filenames.filename_three and
					out_image.image_hash_secondary = verified_metadata_primary_d.targets_metadata.image_hashes.hash_two and
					out_image.image_hash_secondary2 = verified_metadata_primary_d.targets_metadata.image_hashes.hash_three;

				-- SHALL 
				-- Interpreting that "What the primary does" steps should be in order
				guarantee "The ECU does not request/distribute new images (or metadata) during metadata verification":
					(out_image.image_request or out_secondary.image_present or out_secondary.metadata_present.targets_metadata
					 or out_secondary2.image_present or out_secondary2.metadata_present.targets_metadata) => 
					(verification_stage_primary = Agree_Constants::VERIFY_SUCCESS);


				-- SHALL
				guarantee "The ECU verifies images according to the standard":
					if new_image_verified 
        	then (true -> (installed_image_primary = pre (in_image.image)))
					else installed_image_primary = (initial_image -> pre (installed_image_primary));

				-- SHALL
				guarantee "The ECU verifies images for its secondaries":
					if new_image_verified_secondary 
        	then ((true -> (out_secondary.image = pre (in_image.image_secondary))) and
								out_secondary.image_present)
					else ((out_secondary.image = (initialization.secondary_image -> pre (out_secondary.image))) and
								 not out_secondary.image_present);

				guarantee "The ECU verifies images for its secondaries (2)":
					if new_image_verified_secondary2
        	then ((true -> (out_secondary2.image = pre (in_image.image_secondary2))) and
								out_secondary2.image_present)
					else ((out_secondary2.image = (initialization.secondary_image2 -> pre (out_secondary2.image))) and
								 not out_secondary2.image_present);

				-- MODEL
				guarantee "Set ECU software version output":
					ecu_software_version_primary = (0 -> (if new_image_verified then pre (ecu_software_version_primary) + 1 else pre (ecu_software_version_primary)));

				------------------------------------
				--- METADATA VERIFICATION (FULL) ---
				------------------------------------
				-- INITIALIZATION
				guarantee "Initialize metadata":
					((verified_metadata_primary_d = initialization.metadata_d) -> true) and
					((verified_metadata_primary_i = initialization.metadata_i) -> true) and
					((latest_targets_director = initialization.metadata_d.targets_metadata) -> true);

				-- SHALL
				guarantee "The Primary is initialized at the beginning of the verification steps":
					(verification_stage_primary = Agree_Constants::VERIFY_SUCCESS) -> true;
				
				-- MODEL
				--guarantee "The Primary requests metadata when previous verification is complete or failed":
					--true -> 
					--(pre (verification_stage_primary = Agree_Constants::NO_VERIFY) => out_director.metadata_request.root_metadata);

				-- MODEL
				guarantee "There is no recovery from failed metadata verification":
					true -> (pre (verification_stage_primary = Agree_Constants::VERIFY_FAIL) => verification_stage_primary = Agree_Constants::VERIFY_FAIL)

				-- SHALL(?)
				guarantee "Full verification: Root metadata from Director repo":
					true -> (
						if root_director_verified
						then (verified_metadata_primary_d.root_metadata = (in_director.metadata.root_metadata) and
								 out_director.metadata_request.timestamp_metadata and
								 verification_stage_primary = Agree_Constants::ROOT_D)
						else ((verified_metadata_primary_d.root_metadata = pre (verified_metadata_primary_d.root_metadata)) and 
								 verification_stage_primary <> Agree_Constants::ROOT_D)
					);

				-- SHALL(?)
				guarantee "Full verification: Timestamp metadata from Director repo":
					true -> (
						if timestamp_director_verified
						then (verified_metadata_primary_d.timestamp_metadata = (in_director.metadata.timestamp_metadata) and
								 out_director.metadata_request.snapshot_metadata and
								 verification_stage_primary = Agree_Constants::TIMESTAMP_D)
						else ((verified_metadata_primary_d.timestamp_metadata = pre (verified_metadata_primary_d.timestamp_metadata)) and 
								 verification_stage_primary <> Agree_Constants::TIMESTAMP_D)
					);

				-- SHALL(?)
				guarantee "Full verification: Snapshot metadata from Director repo":
					true -> (
						if snapshot_director_verified
						then (verified_metadata_primary_d.snapshot_metadata = (in_director.metadata.snapshot_metadata) and
								 out_director.metadata_request.targets_metadata and
								 verification_stage_primary = Agree_Constants::SNAPSHOT_D)
						else ((verified_metadata_primary_d.snapshot_metadata = pre (verified_metadata_primary_d.snapshot_metadata)) and
								(not out_director.metadata_request.targets_metadata) and 
								 verification_stage_primary <> Agree_Constants::SNAPSHOT_D)
					);

				-- SHALL(?)
				guarantee "Full verification: Targets metadata from Director repo":
					true -> (
						if targets_director_verified
						then (verified_metadata_primary_d.targets_metadata = (in_director.metadata.targets_metadata) and
								 latest_targets_director = (in_director.metadata.targets_metadata) and
								 out_director.metadata_request.root_metadata and
								 verification_stage_primary = Agree_Constants::TARGETS_D)
						else ((verified_metadata_primary_d.targets_metadata = pre (verified_metadata_primary_d.targets_metadata)) and 
								 latest_targets_director = pre (latest_targets_director) and
								 verification_stage_primary <> Agree_Constants::TARGETS_D)
					);

				-- SHALL(?)
				guarantee "Full verification: Root metadata from Image repo":
					true -> (
						if root_image_verified
						then (verified_metadata_primary_i.root_metadata = (in_image.metadata.root_metadata) and
								 out_image.metadata_request.timestamp_metadata and
								 verification_stage_primary = Agree_Constants::ROOT_I)
						else ((verified_metadata_primary_i.root_metadata = pre (verified_metadata_primary_i.root_metadata)) and 
								 verification_stage_primary <> Agree_Constants::ROOT_I)
					);

				-- SHALL(?)
				guarantee "Full verification: Timestamp metadata from Image repo":
					true -> (
						if timestamp_image_verified
						then (verified_metadata_primary_i.timestamp_metadata = (in_image.metadata.timestamp_metadata) and
								 out_image.metadata_request.snapshot_metadata and
								 verification_stage_primary = Agree_Constants::TIMESTAMP_I)
						else ((verified_metadata_primary_i.timestamp_metadata = pre (verified_metadata_primary_i.timestamp_metadata)) and 
								 verification_stage_primary <> Agree_Constants::TIMESTAMP_I)
					);

				-- SHALL(?)
				guarantee "Full verification: Snapshot metadata from Image repo":
					true -> (
						if snapshot_image_verified
						then (verified_metadata_primary_i.snapshot_metadata = (in_image.metadata.snapshot_metadata) and
								 out_image.metadata_request.targets_metadata and
								 verification_stage_primary = Agree_Constants::SNAPSHOT_I)
						else ((verified_metadata_primary_i.snapshot_metadata = pre (verified_metadata_primary_i.snapshot_metadata)) and 
								 verification_stage_primary <> Agree_Constants::SNAPSHOT_I)
					);

				-- SHALL(?)
				guarantee "Full verification: Targets metadata from Image repo":
					true -> (
						if targets_image_verified
						then (verified_metadata_primary_i.targets_metadata = (in_image.metadata.targets_metadata) and
								 out_image.metadata_request.targets_metadata and
								 verification_stage_primary = Agree_Constants::TARGETS_I)
						else ((verified_metadata_primary_i.targets_metadata = pre (verified_metadata_primary_i.targets_metadata)) and 
								 verification_stage_primary <> Agree_Constants::TARGETS_I)
					);

				-- SHALL(?)
				guarantee "Full verification: Targets match between Director and Image repos":
					true -> (
						if targets_match_verified
						then ((verification_stage_primary = Agree_Constants::VERIFY_SUCCESS) and
						       out_secondary.metadata_present.targets_metadata and
									 out_secondary2.metadata_present.targets_metadata)
						else 
						(((pre (verification_stage_primary) <> Agree_Constants::VERIFY_SUCCESS) => verification_stage_primary <> Agree_Constants::VERIFY_SUCCESS) and
						   not out_secondary.metadata_present.targets_metadata and not out_secondary2.metadata_present.targets_metadata);
					);

				-- Should impose an order on the actions of the Primary, like the "what the primary does" section.

				-- ECU version report request from secondary
			**};
	end PrimaryEcu;

	-----------------------------------------
	--------- SECONDARY ECU -----------------
	-----------------------------------------
	system SecondaryECU 
	-- The secondary ECUs perform (partial) verification on metadata and images that they
	-- receive from the primary ECU.

		features
			-- Inputs
			initialization: in data port Data_Types::InitializationBus.impl;
			in_primary: in data port Data_Types::PrimaryToSecondary.impl;
			
			-- Outputs
			out_primary: out data port Data_Types::SecondaryToPrimary.impl;

			-- Model outputs
			installed_image_secondary: out data port Data_Types::Image.impl
			{CASE_Consolidated_Properties::probe => true; };
			verification_stage_secondary: out data port Data_Types::VerificationStage
			{CASE_Consolidated_Properties::probe => true; };
			verified_metadata_secondary: out data port Data_Types::Metadata.impl
			{CASE_Consolidated_Properties::probe => true; };
			ecu_software_version_secondary: out data port Base_Types::Integer
			{CASE_Consolidated_Properties::probe => true; };
			ecu_metadata_version_secondary: out data port Base_Types::Integer
			{CASE_Consolidated_Properties::probe => true; };

			
			-- Assumes and guarantees
			annex agree {**
				eq ecu_id: int = initialization.ecu_id_two -> pre (ecu_id);	
				eq ecu_key: int = initialization.ecu_key_two -> pre (ecu_key);
				eq hardware_id: int = initialization.hardware_id_two -> pre (hardware_id);
				eq initial_image: Data_Types::Image.impl = initialization.secondary_image -> pre (initial_image);
				eq initial_targets: Data_Types::TargetsMetadata.impl = initialization.metadata_d.targets_metadata -> pre (initial_targets);
				eq previous_nonce: int = 0 -> if pre (out_primary.report_present) 
																			then pre (out_primary.ecu_version_report.nonce) 
																			else pre (previous_nonce);
				eq current_time: int = 0 -> (if in_primary.time_present then in_primary.current_time else pre (current_time));
				eq new_targets: Data_Types::TargetsMetadata.impl = in_primary.metadata.targets_metadata;
				eq current_targets: Data_Types::TargetsMetadata.impl = verified_metadata_secondary.targets_metadata;
				eq previous_targets: Data_Types::TargetsMetadata.impl = initialization.metadata_d.targets_metadata -> 
				                                                        (if new_metadata_verified then pre (verified_metadata_secondary.targets_metadata) 
																																												  else pre (previous_targets));
				
				eq new_image_verified: bool = 
				  -- There is an incoming image
					(false -> pre (in_primary.image_present)) and
					-- The image's hardware ID matches this ECU's hardware ID (based on targets metadata)
				  (current_targets.hardware_ids.hardware_id_two = hardware_id) and
					-- SHOULD
					-- The image's release counter is greater than or equal to the previous image's release counter
					-- (based on targets metadata)
					(initialization.optional_features_flag => 
					(true -> (current_targets.release_counters.release_counter_two >= previous_targets.release_counters.release_counter_two))) and
					-- The image's hash matches the hash listed in the metadata
					(false -> (current_targets.image_hashes.hash_two	= pre (in_primary.image.hash))); 

				eq new_metadata_verified: bool = false -> (
					-- There is new incoming targets metadata
					-- MIGHT BE AN ISSUE-- FOR SOME REASON ISN'T TRUE WHEN I EXPECT
					(in_primary.metadata_present.targets_metadata) and
					-- The new Targets metadata reaches the threshold count of valid signatures
					verified_metadata_secondary.root_metadata.targets_threshold_signatures <= 2 and
					Agree_Nodes::Match((new_targets.common_payload.signatures.signature_one), 
														 (new_targets.common_payload.hash),
														 verified_metadata_secondary.root_metadata.targets_public_keys.key_one) and
					Agree_Nodes::Match((new_targets.common_payload.signatures.signature_two), 
														 (new_targets.common_payload.hash),
														 verified_metadata_secondary.root_metadata.targets_public_keys.key_two) and
					-- The new Targets metadata's version number is greater than or equal to that of the current Targets metadata
					(new_targets.common_payload.version) >= (current_targets.common_payload.version) and
					-- The new Targets metadata is not expired
					(new_targets.common_payload.expiration) > current_time and
					-- The new Targets metadata does not list the same ECU ID multiple times
					(
						(new_targets.ecu_ids.ecu_id_one) <> (new_targets.ecu_ids.ecu_id_two) and
						(new_targets.ecu_ids.ecu_id_one) <> (new_targets.ecu_ids.ecu_id_three) and
						(new_targets.ecu_ids.ecu_id_two) <> (new_targets.ecu_ids.ecu_id_three)
					)
				);

				--eq attack_detected: bool = ((in_primary.metadata_present.targets_metadata) and
				                             --not new_metadata_verified);

				---------------------------
				--- ECU VERSION REPORTS ---
				---------------------------
				-- The only strict requirement is that the version report is sent by the time the Primary checks
				-- for updates. Having the Secondary respond to a request from the Primary is the most natural way
				-- to model this.
				-- SHALL
				guarantee "The Secondary ECU sends a version report if and only if it receives a request from the Primary":
						out_primary.report_present = (false -> pre (in_primary).report_request);

				-- SHALL
				guarantee "The ECU version report signature matches the payload":
					out_primary.report_present =>
					Agree_Nodes::Match(out_primary.ecu_version_report.signature, 
					                   out_primary.ecu_version_report.hash, 
														 ecu_key);

				-- SHALL
				guarantee "The ECU version report's ECU ID matches this ECU's ID":
					out_primary.report_present => (out_primary.ecu_version_report.ecu_id = ecu_id);

				-- SHALL
				guarantee "The ECU's currently installed image metadata matches the version report's information (filename, length, and hashes)":
					out_primary.report_present => 
					(
						installed_image_secondary.filename = out_primary.ecu_version_report.image_filename and
					  installed_image_secondary.hash = out_primary.ecu_version_report.image_hash and
						installed_image_secondary.length = out_primary.ecu_version_report.image_length
					);

				-- SHALL
				guarantee "The ECU version report lists the current time":
					out_primary.ecu_version_report.latest_time = current_time;

				-- SHALL
				guarantee "The ECU version report's nonce changes each update cycle":
					out_primary.report_present => 
					out_primary.ecu_version_report.nonce > previous_nonce;

				-- SHOULD
				--guarantee "The ECU version report notes any detected attacks":
					--(initialization.optional_features_flag => 
					--(out_primary.ecu_version_report.attack_detected = attack_detected));

				--------------------------
				--- IMAGE VERIFICATION ---
				--------------------------
				-- SHALL
				guarantee "The Secondary ECU verifies images according to the standard":
					if new_image_verified 
        	then (true -> (installed_image_secondary = pre (in_primary.image)))
					else (installed_image_secondary = (initial_image -> pre (installed_image_secondary)));

				-- MODEL
				guarantee "Set ECU software version output":
					ecu_software_version_secondary = (0 -> (if new_image_verified then (pre (ecu_software_version_secondary) + 1) else (pre (ecu_software_version_secondary))));

				---------------------------------------
				--- METADATA VERIFICATION (PARTIAL) ---
				---------------------------------------
				-- INITIALIZATION
				guarantee "Initialize metadata":
					(verified_metadata_secondary = initialization.metadata_d) -> true;

				-- SHALL (?)
				guarantee "The Secondary ECU verifies metadata according to the standard (partial verification)":
					if new_metadata_verified
					then 
						((true -> (verified_metadata_secondary.targets_metadata = (new_targets))) and
						ecu_metadata_version_secondary = (1 -> pre (ecu_metadata_version_secondary) + 1))
					else 
						(verified_metadata_secondary.targets_metadata = (initial_targets -> pre (verified_metadata_secondary.targets_metadata)) and
						ecu_metadata_version_secondary = (1 -> (pre (ecu_metadata_version_secondary))));

				guarantee "Metadata frame conditions":
					true -> (
						verified_metadata_secondary.root_metadata = pre (verified_metadata_secondary.root_metadata) and
						verified_metadata_secondary.timestamp_metadata = pre (verified_metadata_secondary.timestamp_metadata) and
						verified_metadata_secondary.snapshot_metadata = pre (verified_metadata_secondary.snapshot_metadata)
					);
			**};
	end SecondaryECU;

	-----------------------------------------
	--------- ANOTHER SECONDARY ECU ---------
	-----------------------------------------
	system SecondaryECU2
	-- The secondary ECUs perform (partial) verification on metadata and images that they
	-- receive from the primary ECU.

		features
			-- Inputs
			initialization: in data port Data_Types::InitializationBus.impl;
			in_primary: in data port Data_Types::PrimaryToSecondary.impl;
			
			-- Outputs
			out_primary: out data port Data_Types::SecondaryToPrimary.impl;

			-- Model outputs
			installed_image_secondary: out data port Data_Types::Image.impl;
			verification_stage_secondary: out data port Data_Types::VerificationStage;
			verified_metadata_secondary: out data port Data_Types::Metadata.impl;
			ecu_software_version_secondary: out data port Base_Types::Integer;

			
			-- Assumes and guarantees
			annex agree {**
				eq ecu_id: int = initialization.ecu_id_three -> pre (ecu_id);	
				eq ecu_key: int = initialization.ecu_key_three -> pre (ecu_key);
				eq hardware_id: int = initialization.hardware_id_three -> pre (hardware_id);
				eq initial_image: Data_Types::Image.impl = initialization.secondary_image2 -> pre (initial_image);
				eq initial_targets: Data_Types::TargetsMetadata.impl = initialization.metadata_d.targets_metadata -> pre (initial_targets);
				eq previous_nonce: int = 0 -> if pre (out_primary.report_present) 
																			then pre (out_primary.ecu_version_report.nonce) 
																			else pre (previous_nonce);
				eq current_time: int = 0 -> (if in_primary.time_present then in_primary.current_time else pre (current_time));
				eq new_targets: Data_Types::TargetsMetadata.impl = in_primary.metadata.targets_metadata;
				eq current_targets: Data_Types::TargetsMetadata.impl = verified_metadata_secondary.targets_metadata;
				eq previous_targets: Data_Types::TargetsMetadata.impl = initialization.metadata_d.targets_metadata -> 
				                                                        (if new_metadata_verified then pre (verified_metadata_secondary.targets_metadata) 
																																												  else pre (previous_targets));
				
				eq new_image_verified: bool = 
				  -- There is an incoming image
					(false -> pre (in_primary.image_present)) and
					-- The image's hardware ID matches this ECU's hardware ID (based on targets metadata)
				  (current_targets.hardware_ids.hardware_id_three = hardware_id) and
					-- SHOULD
					-- The image's release counter is greater than or equal to the previous image's release counter
					-- (based on targets metadata)
					(initialization.optional_features_flag => 
					(true -> (current_targets.release_counters.release_counter_three >= previous_targets.release_counters.release_counter_three))) and
					-- The image's hash matches the hash listed in the metadata
					(false -> (current_targets.image_hashes.hash_three	= pre (in_primary.image.hash))); 

				eq new_metadata_verified: bool = false -> (
					-- There is new incoming targets metadataT
					(in_primary.metadata_present.targets_metadata) and
					-- The new Targets metadata reaches the threshold count of valid signatures
					verified_metadata_secondary.root_metadata.targets_threshold_signatures <= 2 and
					Agree_Nodes::Match((new_targets.common_payload.signatures.signature_one), 
														 (new_targets.common_payload.hash),
														 verified_metadata_secondary.root_metadata.targets_public_keys.key_one) and
					Agree_Nodes::Match((new_targets.common_payload.signatures.signature_two), 
														 (new_targets.common_payload.hash),
														 verified_metadata_secondary.root_metadata.targets_public_keys.key_two) and
					-- The new Targets metadata's version number is greater than or equal to that of the current Targets metadata
					(new_targets.common_payload.version) >= (current_targets.common_payload.version) and
					-- The new Targets metadata is not expired
					(new_targets.common_payload.expiration) > current_time and
					-- The new Targets metadata does not list the same ECU ID multiple times
					(
						(new_targets.ecu_ids.ecu_id_one) <> (new_targets.ecu_ids.ecu_id_two) and
						(new_targets.ecu_ids.ecu_id_one) <> (new_targets.ecu_ids.ecu_id_three) and
						(new_targets.ecu_ids.ecu_id_two) <> (new_targets.ecu_ids.ecu_id_three)
					)
				);

				--eq attack_detected: bool = ((in_primary.metadata_present.targets_metadata) and
				                             --not new_metadata_verified);

				---------------------------
				--- ECU VERSION REPORTS ---
				---------------------------
				-- The only strict requirement is that the version report is sent by the time the Primary checks
				-- for updates. Having the Secondary respond to a request from the Primary is the most natural way
				-- to model this.
				-- SHALL
				guarantee "The Secondary ECU sends a version report if and only if it receives a request from the Primary":
						out_primary.report_present = (false -> pre (in_primary).report_request);

				-- SHALL
				guarantee "The ECU version report signature matches the payload":
					out_primary.report_present =>
					Agree_Nodes::Match(out_primary.ecu_version_report.signature, 
					                   out_primary.ecu_version_report.hash, 
														 ecu_key);

				-- SHALL
				guarantee "The ECU version report's ECU ID matches this ECU's ID":
					out_primary.report_present => (out_primary.ecu_version_report.ecu_id = ecu_id);

				-- SHALL
				guarantee "The ECU's currently installed image metadata matches the version report's information (filename, length, and hashes)":
					out_primary.report_present => 
					(
						installed_image_secondary.filename = out_primary.ecu_version_report.image_filename and
					  installed_image_secondary.hash = out_primary.ecu_version_report.image_hash and
						installed_image_secondary.length = out_primary.ecu_version_report.image_length
					);

				-- SHALL
				guarantee "The ECU version report lists the current time":
					out_primary.ecu_version_report.latest_time = current_time;

				-- SHALL
				guarantee "The ECU version report's nonce changes each update cycle":
					out_primary.report_present => 
					out_primary.ecu_version_report.nonce > previous_nonce;

				-- SHOULD
				--guarantee "The ECU version report notes any detected attacks":
					--(initialization.optional_features_flag => 
					--(out_primary.ecu_version_report.attack_detected = attack_detected));

				--------------------------
				--- IMAGE VERIFICATION ---
				--------------------------
				-- SHALL
				guarantee "The Secondary ECU verifies images according to the standard":
					if new_image_verified 
        	then (true -> (installed_image_secondary = pre (in_primary.image)))
					else (installed_image_secondary = (initial_image -> pre (installed_image_secondary)));

				-- MODEL
				guarantee "Set ECU software version output":
					ecu_software_version_secondary = (0 -> (if new_image_verified then (pre (ecu_software_version_secondary) + 1) else (pre (ecu_software_version_secondary))));

				---------------------------------------
				--- METADATA VERIFICATION (PARTIAL) ---
				---------------------------------------
				-- INITIALIZATION
				guarantee "Initialize metadata":
					(verified_metadata_secondary = initialization.metadata_d) -> true;

				-- SHALL (?)
				guarantee "The Secondary ECU verifies metadata according to the standard (partial verification)":
					if new_metadata_verified
					then (true -> (verified_metadata_secondary.targets_metadata = (new_targets)))
					else verified_metadata_secondary.targets_metadata = (initial_targets -> pre (verified_metadata_secondary.targets_metadata));

				guarantee "Metadata frame conditions":
					true -> (
						verified_metadata_secondary.root_metadata = pre (verified_metadata_secondary.root_metadata) and
						verified_metadata_secondary.timestamp_metadata = pre (verified_metadata_secondary.timestamp_metadata) and
						verified_metadata_secondary.snapshot_metadata = pre (verified_metadata_secondary.snapshot_metadata)
					);
			**};
	end SecondaryECU2;
	
	-----------------------------------------
	--------- TIME SERVER -------------------
	-----------------------------------------
	system TimeServer
	-- The time server is a secure source of time for the primary ECU.

		features
			-- Inputs
			
			-- Outputs
			out_primary: out data port Data_Types::TimeServerToPrimary.impl;

			-- Probes
			probe_time_server: out data port Base_Types::Integer;
			
			-- Assumes and Guarantees
			annex agree {**
				-- SHALL
				guarantee "Time is strictly increasing":
					(out_primary.current_time = (0 -> pre (out_primary.current_time) + 1));	

				-- MODEL
				guarantee "Set probe":			
					probe_time_server = out_primary.current_time;
			**};
	end TimeServer;


	-----------------------------------------
	--------- TOP LEVEL SYSTEM --------------
	-----------------------------------------
	system UptaneSystem
		features
			-- Initialization
			initialization: in data port Data_Types::InitializationBus.impl;
			
			-- Model outputs
			installed_image_primary: out data port Data_Types::Image.impl;
			installed_image_secondary: out data port Data_Types::Image.impl;
			installed_image_secondary2: out data port Data_Types::Image.impl;
			verification_stage_primary: out data port Data_Types::VerificationStage;
			verification_stage_secondary: out data port Data_Types::VerificationStage;
			verification_stage_secondary2: out data port Data_Types::VerificationStage;
			verified_metadata_primary_d: out data port Data_Types::Metadata.impl;
			verified_metadata_primary_i: out data port Data_Types::Metadata.impl;
			latest_targets_director_primary: out data port Data_Types::TargetsMetadata.impl;
			verified_metadata_secondary: out data port Data_Types::Metadata.impl;
			verified_metadata_secondary2: out data port Data_Types::Metadata.impl;
			ecu_software_version_primary: out data port Base_Types::Integer;
			ecu_software_version_secondary1: out data port Base_Types::Integer;
			ecu_software_version_secondary2: out data port Base_Types::Integer;
			ecu_metadata_version_secondary: out data port Base_Types::Integer;
			director_latest_targets: out data port Data_Types::TargetsMetadata.impl;

			-- Probes
			probe_time_server: out data port Base_Types::Integer;

			-- Assumes and Guarantees
			annex agree {**
				eq hardware_id_primary: int = initialization.hardware_id_one -> pre (hardware_id_primary);
				eq hardware_id_secondary: int = initialization.hardware_id_two -> pre (hardware_id_secondary);
				eq hardware_id_secondary2: int = initialization.hardware_id_three -> pre (hardware_id_secondary2);

				---------------------------
				--- MODELING PARAMETERS ---
				---------------------------
				assume "Set optional features flag":
					(initialization.optional_features_flag = true) and 
					(true -> (initialization.optional_features_flag = pre (initialization.optional_features_flag)));
					

				----------------------------------
				--- ASSUMPTIONS/INITIALIZATION ---
				----------------------------------
				assume "The ECUs are initialized with a legitimate software image":
					Agree_Nodes::AuthoredByOem(initialization.primary_image.hash) and
					Agree_Nodes::AuthoredByOem(initialization.secondary_image.hash) and
					Agree_Nodes::AuthoredByOem(initialization.secondary_image2.hash) and
					Agree_Nodes::AuthoredByOem(initialization.metadata_d.targets_metadata.image_hashes.hash_one) and
					Agree_Nodes::AuthoredByOem(initialization.metadata_d.targets_metadata.image_hashes.hash_two) and
					Agree_Nodes::AuthoredByOem(initialization.metadata_d.targets_metadata.image_hashes.hash_three);

				assume "The ECUs are initialized with compatible images and targets metadata for compatible images":
					Agree_Nodes::Compatible3(initialization.primary_image.filename, 
																	 initialization.secondary_image.filename,
																	 initialization.secondary_image2.filename) and
					Agree_Nodes::Compatible3(initialization.metadata_d.targets_metadata.image_filenames.filename_one, 
					                        initialization.metadata_d.targets_metadata.image_filenames.filename_two,
																	initialization.metadata_d.targets_metadata.image_filenames.filename_three);

				assume "The ECUs are initialized with valid targets metadata":
					initialization.metadata_d.targets_metadata.hardware_ids.hardware_id_one = initialization.hardware_id_one and
					initialization.metadata_d.targets_metadata.hardware_ids.hardware_id_two = initialization.hardware_id_two and
					initialization.metadata_d.targets_metadata.hardware_ids.hardware_id_three = initialization.hardware_id_three;

				---------------------------
				--- SECURITY GUARANTEES ---
				---------------------------
				-- Functionality (endless data): The ECU never runs out of storage/memory. 
				-- Not modeling memory.

				-- Eavesdrop
				-- Attack is trivially possible (no confidentiality guarantees)

				-- Drop-request
				-- Attack is trivially possible (no availability guarantees)

				-- Partial bundle installation
				-- Attack is trivially possible (no availability guarantees)

				guarantee "Freeze":
				true -> (
					(ecu_metadata_version_secondary > pre (ecu_metadata_version_secondary)) =>
						(verified_metadata_secondary.targets_metadata = director_latest_targets)
				);
					--true;

				guarantee "Mixed-bundles":
					((ecu_software_version_primary = ecu_software_version_secondary1) and
					(ecu_software_version_primary = ecu_software_version_secondary2)) =>
					(
						Agree_Nodes::Compatible3(installed_image_primary.filename,
					                           --installed_image_secondary.filename,
																		 --installed_image_secondary2.filename)
					);
					--true;

				guarantee "Mix-and-match":
					Agree_Nodes::Compatible3(verified_metadata_primary_d.targets_metadata.image_filenames.filename_one,
																	 verified_metadata_primary_d.targets_metadata.image_filenames.filename_two,
																	 verified_metadata_primary_d.targets_metadata.image_filenames.filename_three);
					--true;

				guarantee "Rollback":
					(true -> (installed_image_secondary.version >= pre (installed_image_secondary.version))); 
					--true;

				-- Arbitrary software
				guarantee "Arbitrary software":
					Agree_Nodes::AuthoredByOem(installed_image_secondary.hash);
					--true;

				-- Faulty bundle
				-- Director verifies bad VVM and is therefore susceptible to choosing a flawed new bundle of images


				-- OTHER ATTACKS

				-- Image and ECU incompatible based on ECU hardware ID
				--guarantee "Image incompatible with ECU":
					--Agree_Nodes::Compatible(installed_image_secondary.filename, hardware_id_secondary);
					--true;

				---------------
				--- TESTING ---
				---------------
				-- Should be falsified
				--guarantee "The ECU never finishes a software update: part A":
					--true -> (installed_image_primary.filename = pre (installed_image_primary.filename));
				--guarantee "The ECU never finishes a software update: part B":
					--true -> (installed_image_secondary.filename = pre (installed_image_secondary.filename));
				--guarantee "The ECU never verified new metadata: part A":
					--true -> (verified_metadata_primary_d.targets_metadata = pre (verified_metadata_primary_d.targets_metadata));
				--guarantee "The ECU never verified new metadata: part B":
					--true -> (verified_metadata_secondary.targets_metadata = pre (verified_metadata_secondary.targets_metadata));
				--guarantee "Verification stage X is not reachable":
					--verification_stage_primary <> Agree_Constants::TARGETS_I;
			**};
	end UptaneSystem;
	
	-----------------------------------------
	--------- TOP LEVEL CONNECTIONS ---------
	-----------------------------------------
	system implementation UptaneSystem.Impl
		subcomponents
			director_repo: system DirectorRepo
			{
				CASE_Consolidated_Properties::componentType => SwHwHybrid;
				CASE_Consolidated_Properties::hasSensitiveInfo => true;
				CASE_Consolidated_Properties::insideTrustedBoundary => true;
				CASE_Consolidated_Properties::pedigree => COTS;
				CASE_Consolidated_Properties::canReceiveSWUpdate => false;
				CASE_Consolidated_Properties::canReceiveConfigUpdate => false;
				CASE_Consolidated_Properties::supplyChainSecurity => 0;
			};
			image_repo: system ImageRepo
			{
				CASE_Consolidated_Properties::componentType => SwHwHybrid;
				CASE_Consolidated_Properties::hasSensitiveInfo => true;
				CASE_Consolidated_Properties::insideTrustedBoundary => true;
				CASE_Consolidated_Properties::pedigree => COTS;
				CASE_Consolidated_Properties::canReceiveSWUpdate => false;
				CASE_Consolidated_Properties::canReceiveConfigUpdate => false;
				CASE_Consolidated_Properties::supplyChainSecurity => 0;
			};
			primary_ecu: system PrimaryEcu
			{
				CASE_Consolidated_Properties::componentType => SwHwHybrid;
				CASE_Consolidated_Properties::hasSensitiveInfo => true;
				CASE_Consolidated_Properties::insideTrustedBoundary => true;
				CASE_Consolidated_Properties::pedigree => COTS;
				CASE_Consolidated_Properties::canReceiveSWUpdate => false;
				CASE_Consolidated_Properties::canReceiveConfigUpdate => false;
				CASE_Consolidated_Properties::supplyChainSecurity => 0;
			};
			secondary_ecu: system SecondaryECU
			{
				CASE_Consolidated_Properties::componentType => SwHwHybrid;
				CASE_Consolidated_Properties::hasSensitiveInfo => true;
				CASE_Consolidated_Properties::insideTrustedBoundary => true;
				CASE_Consolidated_Properties::pedigree => COTS;
				CASE_Consolidated_Properties::canReceiveSWUpdate => false;
				CASE_Consolidated_Properties::canReceiveConfigUpdate => false;
				CASE_Consolidated_Properties::supplyChainSecurity => 0;
			};
			secondary_ecu2: system SecondaryECU2
			{
				CASE_Consolidated_Properties::componentType => SwHwHybrid;
				CASE_Consolidated_Properties::hasSensitiveInfo => true;
				CASE_Consolidated_Properties::insideTrustedBoundary => true;
				CASE_Consolidated_Properties::pedigree => COTS;
				CASE_Consolidated_Properties::canReceiveSWUpdate => false;
				CASE_Consolidated_Properties::canReceiveConfigUpdate => false;
				CASE_Consolidated_Properties::supplyChainSecurity => 0;
			};
			time_server: system TimeServer
			{
				CASE_Consolidated_Properties::componentType => SwHwHybrid;
				CASE_Consolidated_Properties::hasSensitiveInfo => true;
				CASE_Consolidated_Properties::insideTrustedBoundary => true;
				CASE_Consolidated_Properties::pedigree => COTS;
				CASE_Consolidated_Properties::canReceiveSWUpdate => false;
				CASE_Consolidated_Properties::canReceiveConfigUpdate => false;
				CASE_Consolidated_Properties::supplyChainSecurity => 0;
			};
			
		connections
			-- Uptane protocol connections
			c1: port director_repo.out_primary -> primary_ecu.in_director;
			c2: port primary_ecu.out_director -> director_repo.in_primary;

			c3: port image_repo.out_primary -> primary_ecu.in_image;
			c4: port primary_ecu.out_image -> image_repo.in_primary;

			c5: port primary_ecu.out_secondary -> secondary_ecu.in_primary;
			c6: port secondary_ecu.out_primary -> primary_ecu.in_secondary;

			c14: port primary_ecu.out_secondary2 -> secondary_ecu2.in_primary;
			c15: port secondary_ecu2.out_primary -> primary_ecu.in_secondary2;

			c7: port time_server.out_primary -> primary_ecu.in_time_server;

			-- Initialization
			c8: port initialization -> director_repo.initialization
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c11: port initialization -> primary_ecu.initialization
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c12: port initialization -> secondary_ecu.initialization
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c16: port initialization -> secondary_ecu2.initialization
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c29: port initialization -> image_repo.initialization
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};

			-- Model inputs
			--c13: port in_images -> image_repo.in_images;

			-- Model outputs
			c9: port primary_ecu.installed_image_primary -> installed_image_primary
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c10: port secondary_ecu.installed_image_secondary -> installed_image_secondary
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c17: port secondary_ecu2.installed_image_secondary -> installed_image_secondary2
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c18: port secondary_ecu.verification_stage_secondary -> verification_stage_secondary
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c20: port secondary_ecu2.verification_stage_secondary -> verification_stage_secondary2
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c19: port primary_ecu.verification_stage_primary -> verification_stage_primary
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c21: port primary_ecu.verified_metadata_primary_d -> verified_metadata_primary_d
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c30: port primary_ecu.verified_metadata_primary_i -> verified_metadata_primary_i
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c22: port secondary_ecu.verified_metadata_secondary -> verified_metadata_secondary
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c23: port secondary_ecu2.verified_metadata_secondary -> verified_metadata_secondary2
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c24: port time_server.probe_time_server -> probe_time_server
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c25: port primary_ecu.ecu_software_version_primary -> ecu_software_version_primary
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c26: port secondary_ecu.ecu_software_version_secondary -> ecu_software_version_secondary1
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c27: port secondary_ecu2.ecu_software_version_secondary -> ecu_software_version_secondary2
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c28: port primary_ecu.latest_targets_director -> latest_targets_director_primary
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c31: port director_repo.latest_targets -> director_latest_targets
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
			c32: port secondary_ecu.ecu_metadata_version_secondary -> ecu_metadata_version_secondary
				{
					CASE_Consolidated_Properties::connectionType => Trusted;
				};
	end UptaneSystem.impl;
end Uptane;